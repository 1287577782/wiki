MIPS架构学习笔记 
                                    张驿风
                                 20060905
  最近在学习MIPS架构，在系统计算机研究所的网上读了不
少关于MIPS的好文，下面的笔记就是基于上面的好文的摘抄。
一: MIPS寄存器别名记忆:
这一段在学习MIPSCPU架构，一直对mips的32个寄存器的
约定俗成的别名感到迷惑，今天在系统计算机研究所的网
(http://www.xtrj.org/)上看到一篇文章里有这方面的介
绍，一下子豁然开朗原来这里的v,a,t前缀就是英文单词
的缩写呀。（呵呵，以前害得俺在>书上
都没有找到有助于理解的介绍）
;REGISTER NAME USAGE 
{{{
$0 $zero        常量0(constant value 0) 
$2-$3 $v0-$v1   函数调用返回值(values for results and expression evaluation) 
$4-$7 $a0-$a3   函数调用参数(arguments) 
$8-$15 $t0-$t7  暂时的(或随便用的) 
$16-$23 $s0-$s7 保存的(或如果用，需要SAVE/RESTORE的)(saved) 
$24-$25 $t8-$t9 暂时的(或随便用的) 
$28 $gp         全局指针(Global Pointer) 
$29 $sp         堆栈指针(Stack Pointer) 
$30 $fp         帧指针(Frame Pointer) 
$31 $ra         返回地址(return address)
}}}
二: MIPS 存储空间分配
MIPS将存储空间分为4块分别是:
kuseg, kseg0,kseg1 and kseg2
1. 0xFFFF FFFF mapped            kseg2 
2. 0xC000 0000 unmapped uncached kseg1 
3. 0xA000 0000 unmapped cached   kseg0 
4. 0x8000 0000 2G                kuseg 
                 ------------------------                                       
                | Mapped         (kseg2) |   1 GB                               
                |                        |                                      
0xc000 0000      ------------------------                                       
                |Unmapped uncached(kseg1)|   512MB                              
0xa000 0000      ------------------------                                       
                | Unmapped cached(kseg0) |   512 MB                             
0x8000 0000      ------------------------                                       
                | 32-bit userspace kuseg |                                      
                |                        |   2 GB                               
                |                        |                                      
                |                        |                                      
0x0000 0000      ------------------------   

kuseg: 虚拟空间 0x0000 0000 - 0x7FFF FFFF ( 低端 2G) ：这些地址是用户态 可用的地址。在有 MMU 的机器里，这些地址将一概被 MMU 作转换 ，除非 MMU 的设置被建立好，否则这 2G 地址是不可用的。对于没有 MMU 的机器，存取这 2G 地址的方法依具体机器相关，你的 CPU 具体厂商提供的手册将会告诉你关于这方面的信息。如果想要你的代码在有或没有 MMU 的 MIPS 处理器之间有兼容性，尽量避免 这块区域的存取。
 
kseg0: 虚拟空间 0x8000 0000 - 0x9FFF FFFF(512M): 这些地址映射到物理地址简单的通过把最高位清零，然后把它们映射到物理地址低段 512M(0x0000 0000 - 0x1FFF FFFF) 。因为这种映射是很简单的，通常称之为“非转换的” 地址区域。几乎全部的对这段地址的存取都会通过快速缓存 (cache) 。因此在 cache 设置好之前，不能随便使用这段地址。通常一个没有 MMU 的系统会使用这段地址作为其绝大多数程序和数据的存放位置。对于有 MMU 的系统，操作系统核心会存放在这个区域。
 
kseg1: 虚拟空间 0xA000 0000 - 0xBFFF FFFF(512M): 这些地址通过把最高 3 位清零的方法来映射到相应的物理地址上，与 kseg0 映射的物理地址一样 。但 kseg1 是非 cache 存取的。 kseg1 是唯一的在系统重启时 能正常工作的地址空间。这也是为什么重新启动时的入口向量是 0xBFC0 0000 。这个向量相应的物理地址是 0x1FC0 0000 。你将使用这段地址空间去存取你的初始化 ROM 。大多数人在这段空间使用 I/O 寄存器。如果你的硬件工程师要把这段地址空间映射到非低段 512M 空间，你得劝说他。
 
kseg2: 虚拟空间 0xC000 0000 - 0xFFFF FFFF (1G): 这段地址空间只能在核心态 下使用并且要经过 MMU 的转换 。在 MMU 设置好之前，不能存取这段区域。除非你在写一个真正的操作系统，一般来说你不需要使用这段地址空间。

   呵呵可以直观的看到只有kseg1是不需要映射(物理虚拟转换)，没有被缓存
的，也就是说只有kseg1的内存区域可以做引导的存储区(在这里放置引导用
flash存储器).被cached区域必须等到MMU 的TLB被初始化后才可以使用的。
eg；其中 xkphys 是固定映射，不经 TLB (unmapped)
    用户空间是 xuseg
:MIPS的CPU运行有3个态
1. User Mode.
2. Supervisor Mode.
3. and Kernel Mode. 
   For simplicity, let's just talk about User Mode and Kernel Mode. 
Please always keep this in mind: 
CPU can ONLY access kuseg memory area when running in User Mode 
CPU MUST be in kernel mode or supervisor mode when visiting kseg0, kseg1 
and kseg2 memory area。
   呵呵，可以看出MIPS的CPU运行态和x86尤其是ARM基本都是一样的。就是用户层
对物理空间地址的访问是也是受限制的(现代操作系统的先进之处吗)，必须通过使
用驱动方式把操作代码运行在核心态。
四: MMU TLB 
  MIPS CPU通过TLB来translates all virtual addresses generated by the CPU.
下面谈谈ASID(Address Space Identifier). Basically, ASID, plus the VA(Vir
tual Address) are composed of the primary key of an TLB entry. 换句话说，
虚拟 地址本身是不能唯一确定一个TLB entry的。一般而言，ASID的值就是相应的
process ID. Note that ASID can minimized TLB re-loads, since several TLB
entries can have the same virtual page number, but different ASID's. 对
于一个多任务操 作系统来讲，每个任务都有 自己的4G虚拟空间
五: MMU 控制寄存器 
对于一个Kernel Engineer来说，对MMU的处理主要是通过MMU的一些控制寄存器来完成
的。MIPS体系结构中集成了一个叫做System Control Coprocessor (CP0)的部件。CP0
就是我们常说的MMU控制器。在CP0中，除了TLB entry(例如，对RM5200，有48pair,96
个TLB entry),一些控制寄存器提供给OS KERNEL来控制MMU的行为。 
每个CP0控制寄存器都对应一个唯一的寄存器号。MIPS提供特殊的指令来对CP0进行操作。 
mfc0 reg. CP0_REG 
mtc0 reg. CP0_REG 
我们通过上述的两条指令来把一个GPR寄存器的值assign给一个CP0寄存器，从而达到
控制MMU的目的。 
面简单介绍几个与TLB相关的CP0控制寄存器。 
Index Register 
这个寄存器是用来指定TLB entry的，当你进行TLB读写的时候。我们已经知道，例如，
MIPS R5提供了48个TLB pair，所以index寄存器的值是从0到47。换句话说，每次TLB写
的行为是对一个pair发生的。这一点是与其他的CPU MMU TLB 读写不同的。 
EntryLo0, EntryLo1 
这两个寄存器是用来specify 一个TLB pair的偶(even)和奇(odd)物理(Physical)页面
地址。 
一定要注意的是：
EntryLo0 is used for even pages; EntryLo1 is used for odd pages. 
Otherwise, the MMU will get exception fault. 
Entry Hi 
Entry Hi寄存器存放VPN2，或一个TLB的虚拟地址部分。注意的是：ASID value也是在
这里被体现。 
Page Mask 
MIPS TLB提供可变大小的TLB地址映射。一个PAGE可以是4K，16K，64K，256K，1M，4M
或16M。这种可变PAGE SIZE提供了很好的灵活性，特别是对Embedded System Software. 
对于Embedded System Softare,一个很大的区别就是：不允许大量的Page Fault. 
这一点是传统OS或General OS在Embedded OS上的致命缺陷。也是为什么POSIX 1。B的
目的所在。传统OS存储管理的一个原则就是：Page On Demand.这对大多Embedded 
System是不允许的。 For embedded system,往往是需要在系统初始化的时刻就对所有的 
存储进行configuration， 以确保在系统运行时不会有Page Fault. 
上述几个寄存器除了MAP一个虚拟页面之外，还包括设置一个页面的属性。其中包括： 
writable or not; invalide or not; cache write back or write through 
下面简单谈谈MIPS的JTLB。 
在MIPS中，如R5000， JTLB is provided. JTLB stands for Joint TLB. 什么意思呢？
就是 TLB buffer中包含的mixed Instruction and Data TLB 映射。有的CPU的Instruction
TLB 和Data TLB buffer 是分开的。 
当然MIPS(R5000)确实还有两个小的，分开的Instruction TLB和Data TLB。但其大小很小。
主要是为了Performance,而且是对系统软件透明的。 
在这里再谈谈MMU TLB和CPU Level 1 Cache的关系。 
我们知道，MIPS，或大多数CPU，的Level 1 Cache都是采用Virtually Indexed and P
hysicall tagged. 通过这个机制，OS就不需要在每次进程切换的时候去flush CACHE。
为什么呢？ 
举一个例子吧： 
进程A的一个虚拟地址Addr1，其对应的物理地址是addre1； 
进程B的一个虚拟地址Addr1，其对应的物理地址是addre2; 
在某个时刻，进程A在运行中，并且Addr1在Level 1 CACHE中。 
这时候，OS does a context swith and bring process B up, having process A sleep. 
Now, let's assume that the first instruction/data fetch process B does is to 
access its own virtual address Addr1. 
这时候CPU会错误的把进程A在Level 1中的Addr1的addr1返回给CPU吗？ 
我们的回答应该是：不会的。 
原因是： 
当进程切换时，OS会将进程B的ASID或PID填入ASID寄存器中。请记住：对TLB的访问，
(ASID + VPN)才是Primary Key. 由于MIPS的CACHE属性是Virtually Indexed, 
Physically tagged.所以，任何地址的访问，CPU都会issue the request to MMU for
TLB translation to get the correct physical address, which then will be used 
for level cache matching. 
与此同时，CPU会把虚拟地址信号传给Level 1 Cache 控制器。然后，我们必须等待MMU
的Physical Address数据。只有physical tag也 匹配上了，我们才能说一个：Cache Hit. 
所以，我们不需要担心不同的进程有相同的虚拟地址的事情。 
弟兄们可以重温一下我们讲过的Direct Mapped; Full Associative, and Set Associative. 
从而理解为什么Cache中可以存在多个具有相同虚拟地址的entry. For example,the above 
Addr1 for proccess A and Addr1 for process B.
