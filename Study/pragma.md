## 结构中有数组、结构体、结构体数组的对齐方式
32位:
```
A. struct P1 { short a[3]; char b[3]; };//6+3 = 9 然后9按照2对齐 =10
B. struct P2 { short a[3]; char *b[3]; }; //6+4*3=18 按照4对齐=20
C. struct P3 { struct P2 *a; char b; struct P1 a[2]; };//4+1+2*10=25  按照4对齐到28
```
64位再例:
```
typedef struct __url_entry{
	char *url;
	uint32_t act:3,
		 rst_en:1,
		 fwd_grp:6,
		 _rsv:22;
}url_entry;

typedef struct _url_block{
	url_entry entry[7];
	struct _url_block *next;
}url_block;
```
上面第一个结构体大小是`16`位（指针类型`8`位---按照此大小对齐）.第二个结构体大小是`120(16 * 7 + 8)`,所以不是按照本结构中的成员的组合类型的大小对齐,而是基本类型中最大的.
第一个数组按照数组类型大小进行排列:`16 * 7 = 112`;正好是`8`位对齐的,后面的指针也就紧挨着排列,整个结构体大小是`120`.

> 在第二个结构体中已经说明结构体数组是按照结构体的大小进行排列的
```
url_block arr[3];
&arr[0];	0
&arr[1];	120
&arr[2];	240
```
数组都是按照结构体类型大小进行排列的,也同时满足了对齐。

## pragma
`#pragma pack(n)`来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的$偏移量$有两种情况：
* 第一、如果n大于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式
 
* 第二、如果n小于改变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式

结构体的总大小也有个约束条件， 如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。

> 其实pragma就是对于类型对齐大于设定值的其作用，在小于最大对齐要求，降低结构的对齐要求。

## __attribute__
`__attribute__((aligned(m)))`告诉编译一个结构体或者类或者联合或者一个类型的变量分配地址空间时的地址对齐方式。也就是说，如果将`__attribute__((aligned(m)))`作用于一个类型，那么该类型的变量在分配地址空间时，其存放的地址一定按照m字节对齐（m必须是2的幂次方）。并且其占用的空间，即大小也是m的整数倍，以保证在申请连续存储空间的时候，每个元素的地址也是按照m字节对齐。

在64位机下，即使含有一个指针类型变量的结构它是8字节对齐的，但是一个这样的结构变量的起始地址有16、48、32的余数。所以结构自身起始地址是没有限制的。

但是如果加上了align属性，不会影响结构内部成员的对齐，会影响结构体的起始地址的对齐和结构的大小。
