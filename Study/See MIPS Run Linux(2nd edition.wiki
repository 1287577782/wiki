MIPS五级流水线：
	IF(instruction fetch) 取指，从指令高速缓存(I-cache)获取下一条指令。

	RD(read register) 读寄存器，读取该指令的源寄存器域指定的CPU寄存器的内容。

	ALU(arithmetic/logic unit) 在一个时钟周期内完成算术或者逻辑操作(浮点运算
	和整数乘除无法在一个时钟周期内完成，对其处理有所不同)

	MEM(mem) 访问内存该阶段指令可以读写数据高速缓存(D-cache)中的内存变量，平
	均而言，每四条指令中就有三条指令在该阶段没有任何操作，但是每条指令都分配
	了这一阶段以确保不会出现两条指令同时需要访问数据高速缓存的情形。

	WB(write back)写回寄存器,将操作结果值写道寄存器中.

	MIPS所有的指令长度都是32位，MIPS的二进制文件比典型的80*86大百分之二十到三
	十。但是不可能把一个32位常数放进单个指令中。MIPS留出26位常数的空间用以编
	码跳转和调用指令的目标地址，这样的指令只有两条。其他指令只能有16位空间留
	给常数。这样装入任意32位数值需要一个两条指令的序列，条件分支被限制到64K		指令序列；代码段取指，条件分支
	指令范围。

	三操作数的指令：
	算术/逻辑指令都不需要指定内存地址，所以空出了充足的指令位可以定义两个独立
	的源操作数和一个目的操作数。

	没有条件码：
	MIPS的指令集的一个特征就是没有条件标志，许多体系结构有多个标志位来表示运算
	结果的“进位”，“为零”等等。CISC的典型做法是根据一些指令的操作结果设置这些标
	志，有些RISC体系结构保留了标志位。
	MIPS体系结构把所有信息保存到寄存器堆中。比较指令设置通用寄存器，条件分支指
	令检测通用寄存器。
	这里有效的条件分支意味着是否分支的决定必须在半个流水线周期内作出；该体系结
	构通过保持分支决策的测试条件简单有助于实现这一点。所以MIPS的条件分支只测试
	单个寄存器的符号/为零或者一对寄存器是否相等。

	指令在内存中都是四字节边界对齐的:
	MIPS指令的最小操作码域为6位，留出了26位来定义跳转的目标，因为所有指令在内
	存中都是四字节边界对齐的，低两位无需保存，这样可有2^28=256MB的地址范围(段	指令是四字节对齐，那么数据呢？
	内绝对地址)。
	条件分支只有16位的偏移域---给出了2^18字节的范围，因为指令都是四字节对齐的。
	四字节对齐 ： 内存中是四字节对齐是说只需要指向四字节的第一个地址就OK了，

寻址和访存:
	访问内存只能通过简单的寄存器加载和存储:每次内存访问都要一条显式的加载或存
	储指令。

	只有一种数据寻址方式:几乎所有的加载和存储都通过单个寄存器基址加上一个16位
	的常数偏移量寻址内存。

	字节地址指令:一旦数据存入MIPS CPU的寄存器，所有的操作都是在整个寄存器上操
	作。但是像C这样的语言语义不适合不能寻址内存到字节粒度的机器。因而MIPS对8-
	和16-位变量(分别称为字节和办字)提供了一套完整的装入/存储操作.一旦数据到达
	寄存器，就当作寄存器全长来处理.所以部分字加载指令有两种形式——符号扩展和零
	扩展。

	load/store必须对齐:内存操作只能对齐到相应数据类型边界的地址加载和存储数据。
	字节可以在任意地址传输，但是半字必须在偶数地址对齐，字在四字节边界对齐。
	许多CISC微处理器可以从任意字节地址加载/存储四字节数据，但是要花费额外的时
	钟周期。

	跳转指令:有限的32位指令长度想要支持很大程序的体系结构上对分支是个问题。MI
	PS指令的最小操作码域为6位，留出了26位来定义跳转的目标。因为所有指令在内存
	中都是四字节对齐边界的，低两位地址无需保存，这样有2^28=256MB的地址范围。
	这个地址不是相对PC的，而是解释成256MB段内的绝对地址。这对于大于256MB的单个
	程序极为不便。
	超出段内的分支可以通过使用一个寄存器跳转指令做到，该指令可以跳到任意32位地
	址。
	条件分支只有16位的偏移域——给出了2^18字节的范围，因为指令都是四字节对齐的--
	解释成相对PC的带符号的偏移量。如果知道分支目标会在紧跟分支之后的指令的128K
	B范围内，编译器就能只生成一个简单的条件分支指令。


MIPS没有的特性：
	没有字节或半字数据的运算：所有算术和逻辑操作都是在32位的数据上进行。字节或
	半字的运算需要大量额外的资源和许多额外的操作码，而且很少有用。C语言的语法
	让大多数的计算用int类型，对MIPS而言int就是32位的整数。然而当程序明确做sh-
	ort或者char运算时，MIPS编译器必须插入额外的代码以保证结果回绕和溢出，生成	是不是声明使用半字，字节会影响速度？
	跟16-或8-位机器上一样的结果。

	没有对堆栈的特殊支持：传统MIPS汇编确实定义一个寄存器作为堆栈指针，但是硬
	件上SP没有任何特殊之处。有一种推荐的关于子程序调用的栈帧布局，这样可以混
	合不同语言和编译器的模块；你应当遵守这些约定，但是这些与硬件无关。堆栈弹
	出不能适应流水线，因为有两个寄存器要写（来自堆栈的数据和增加指针值）。

	最少的子程序支持：有一点比较特别，跳转指令有一个跳转并连接的选项，把返回
	地址存入一个寄存器，默认是$31.所以习惯上用31作为返回地址寄存器.这样做比
	起把返回地址保存到堆栈上要简单，但却带来明显的好处。第一保持了分支和访存
	指令的完全分离；第二，当调用许多根本不需要在堆栈保存返回地址的小程序时，
	这样有助于提高效率。

	最少的中断处理：
	最少的异常处理：
流水：
	数据加载延迟 	:加载延迟槽。

	延迟分支	:分支延迟槽。
	分支延迟槽 (Branch delay slot)，简单地说就是位于分支指令后面的一条指令，
	不管分支发生与否其总是被执行，而且位于分支延迟槽中的指令先于分支指令提交
	(commit)。
	如：
	jal printf
	move $4,$6
	xxx #move指令总是被执行的。
	分支延迟槽在 DSP 和历史较悠久的 RISC 上比较常见，如 MIPS,  SPARC 等。Po-
	werPC 和 ARM 上则没有这个概念。x86 亦没有。
	这种技术手段主要用在早期没有分支预测的流水线 RISC 上，现代 RISC 实现早就
	可以在流水线的第 2 级利用分支预测确定跳转的目标，分支延迟槽也就失去了原
	来的价值，但为了软件上的兼容性 MIPS 和 SPARC 还是作了保留。

MIPS指令可以分成以下各类：
	空操作no-op
	寄存器/寄存器传输
	常数加载：作为数值和地址的整型立即数
	算术/逻辑指令
	整数乘法、除法和求余数
	整数乘加
	加载和存储
	跳转、子程序调用和分支
	断点和自陷
	cp0功能：CPU控制指令
	浮点
	用户态的受限访问：rdhwr和synci
注：64位版本以d开头表示，无符号数以u结尾，立即数以i结尾，双子操作以d结尾，字以w

第2章	MIPS体系结构
	计算机也是如此——如果你有某种极端的或者超常规的需求，实现的细节就对你很重
	要了。
	一般而言，一个CPU的体系结构包括一组指令集加上一些寄存器的知识。指令集与
	体系结构这两个术语基本上是同义词。ISA(Instruction Set Architeture指令集
	体系结构)。
寄存器：
	0	zero	永远返回0
	1	at	(assembly temporary汇编暂存)保留给汇编器使用
	2-3	v0,v1	子程序返回值,用来存放子程序返回的非浮点值。如果要返回的值
			太大，这两个寄存器放不下编译器将会通过内存来完成。
	4-7	a0-a3	(arguments)子程序调用的前4个参数
	8-15	t0-t7	(temporaries)临时变量，子程序使用时无需保存
	24-25	t8-t9	
	16-25	s0-s7	子程序寄存器变量；子程序写入时必须保存其值并返回前恢复原
			值，从而调用函数看到这些寄存器的值没有变化。
	26-27	k0,k1	保留给中断或自陷处理程序使用；其值可能在你眼皮地下改变
	28	gp	(global pointer)全局指针；一些运行系统维护这个指针以便于
			存取static和extern变量.
	29	sp	(stack pointer)堆栈指针
	30	s8/fp	第九个寄存器变量；需要的子程序可以用来做帧指针(frame po-	fp帧指针
			inter)
	31	ra	子程序的返回地址,永远由正常函数调用指令jal存放返回地址。
--------------------------------------------------------------------------------	
	s0-s8	依照约定，必须保证这些寄存器的内容在子程序返回时要和子程序入口的
		值相同，要么在子程序里不用这些寄存器，要么把它们保存在堆栈上并在
		子程序返回时恢复。这些约定使得这些寄存器非常适合作为寄存器变量，
		或存放一些在子程序调用期间必须保存的值。

	程序计数器:
	用于存放下一条指令所在单元的地址的地方。单片机及汇编语言中常称作PC（Pr-
	ogram Counter）。

	gp:用于两个不同目的。对于linux程序使用的一类位置无关的代码PIC，本模块外的
	代码和数据引用都要通过一个称为全局偏移量表GOT(global offset table)的指针
	表。gp寄存器用来维护指向该表的指针。
	在常规的非PIC代码(在简单的嵌入式系统中会用到)中，gp有时用来指向一个链接时
	确定位置的静态数据中部。这意味着，利用gp作基指针，对于在gp指针前后32k范围
	内的数据存取，只需要一条指令就可完成。
	如果没有全局指针，存取一个静态数据区域的值需要两条指令：一条是获取由编译
	器和装载程序计算去的32位地址常量的高位，另外一条才真正存取数据。
	要建立相对于gp的地址应用，编译器在编译时刻必须知道一个数据链接后的内存地
	址在64K范围之内。实际上这是不可能知道的，只能靠猜测。通常的做法是把小的(
	八字节以内的)全局数据项放在gp的区域内，如果还是太大，就让链接器发出警告。

	sp:堆栈指针的上下移动需要显式的通过指令来实现，因此MIPS通常只在子程序入口
	处把sp调整到子程序中间堆栈可能达到的最低点，从而编译器可以通过相对与sp的固
	定偏移量来存取堆栈变量。

	fp:帧指针，也叫做s8.如果由于某种原因编译器或程序员不能或不愿计算相对于堆栈
	指针的偏移量，子程序可以通过帧指针来记录/跟踪堆栈的情况。

	ra:在任何一个子程序入口处，ra寄存器中保存着返回地址——因此典型的子程序都以
	一条jr ra指令结尾。理论上讲，这里可以使用任意寄存器，但是一些复杂的CPU因
	为采用优化技巧(分支预测)，使得jr ra时效果会更好。

整数乘法部件及寄存器 lo hi
	因为乘法的结果返回没有快到能自动供随后的指令使用的程度，乘法的结果寄存器
	总是互锁的。在乘法运算完成之前任何企图读取结果的操作都将导致CPU停下来等
	待乘法操作结束。
	整数乘法器也可以执行两个通用寄存器的除法操作。lo(商),hi(余).
	乘法要用4-12个周期，除法要用20-80个周期。

加载与存储：寻址方式
	MIPS只有一种寻址方式，任何加载或存储操作的机器指令都可以写成：
	lw $1, offset($2)
	可以用任何寄存器作为目标和源寄存器。偏移量offset是一个有符号的16位的数字
	(-32768 32767);加载所用的程序地址是$2寄存器的值与offset的和。这种寻址方
	式一般已足够存取C语言结构体的一个成员。

寄存器与寄存器的数据类型
	MIPS CPU可以在一次操作中装载或存储一到八个字节。				指令是4四字节对齐的，数据的话?
	long long	dword	8	ld--->d
	int		word	4	lw--->w
	short		halfword 2	lh--->h
	char		byte	1	lb--->b
整数数据类型
	字节byte和半字halfword的加载方式有两种。符号扩展的指令lb lh指令将数据值存
	放在32为寄存器的地位，并将高位用符号位（字节的位7，半字的位15）的值来填充。

	无符号的指令lbu和lhu用零来扩展数据，将数据值加载到32为寄存器的地位中,并用
	零来扩充高位。
	例如：假设寄存器t1中是存储器中一个byte字节宽度数据的地址，该处存放的值为
	0xFE(有符号数-2或无符号数254)，那么
	lb	t2, 0(t1)
	lbu	t3, 0(t1)
	执行之后，寄存器t2的值为0xFFFF FFFE(有符号数-2)，t3的值会是0x0000 00FE(有
	符号数或无符号数254)

未对齐的加载和存储
	MIPS体系结构中，正常的加载和存储必须对齐；半字只能从双字节的边界加载；字
	只能从四字节的边界加载。一个对非对齐的地址的加载指令会导致自陷.或者按照宏
	命令（由多个命令组成）。
	linux-gcc也会按照类型对齐uint16_t双字节对齐，所以链接后它的地址肯定是2(按
	字节寻址）的倍数,int是4的倍数。

内存中的浮点数据
	l.d	$f2, 24(t1) ==
	lwc1	$f2, 24(t1)
	lwc1	$f3, 28(t1)
	在64为CPU上，任何一个遵循MIPS/SGI规则的C编译器都将八字节长的双精度浮点变量
	对齐到八字节的地址边界上。32为硬件并没有这样的对齐要求，对齐仅仅是为了向后
	兼容。

汇编语言的合成指令：
GNU的汇编器会合成一些指令，只需要写一个li(加载立即数)指令，汇编器会知道什么时候要生成两条机器指令。要明确区分合成指令与机器指令。
---------------------------------------------------------------------------------------------------------------------------------------
汇编器所做的：
	32位立即数的加载，写一个加载任何值的代码，汇编器将会把其拆开成为两个指令，
	分别加载这个数据的高半部分和低半部分。

	从内存地址加载，写一个加载驻留内存的变量的代码。汇编器通常会将这个替换成
	两个指令，先是一条把变量地址的高位加载到临时寄存器的指令，接着是一条以该
	变量的低位为偏移量的加载指令。当然这不适用于C语言函数内部定义的局部变量，
	局部变量是通过寄存器或堆栈实现的。

	对内存变量的快速存取，有些c程序包含许多对static和extern变量的引用，对他们
	加载/存储用两条指令开销太大了。有些编译系统，在编译/汇编时(最常见的做法是
	汇编器选择占用八个字节或更小空间的变量)选择一些变量，并将他们一起存放到最
	后大小在64K字节以内的一个内存区。然后运行时系统初始化一个寄存器——习惯上用
	$28也就是gp——来指定该内存去的中间位置。对这些变量数据的加载和存储现在就可
	以通过一条相对gp寄存器寻址的加载或存储指令来完成。

	更多类型的分支条件：汇编器合成了一整套根据两个寄存器的算术运算结果来进行
	条件分支的指令。

	同一指令的简写或多种不同的写法：像not和neg这样的单目运算，是通过与永远是
	零值的寄存器$0的nor或sub来实现的。你还可以把一个三个操作数的指令写成两个
	操作数的形式，汇编器将会把结果写到给出的第一个寄存器中

	隐藏分支延迟槽：在正常的情况下，汇编器如果看出将写在分支之前的指令移动到
	延迟槽没问题的话，就会这样做。因为汇编器能够看出的情况不多，所以不太善于
	填充延迟槽。有一条汇编伪指令.set noreorder可以用来告诉汇编器不要自动移动
	指令，由程序员人工控制。

	隐藏加载延迟槽：有些汇编器会检测到紧接加载指令后试图使用加载结果的指令，
	如果行的话可能会上下移动一条指令。

	未对齐的数据传送：非对齐的加载/存储指令(ulh, ulw等待)能正确的存取半字和
	字数据，即使目标地址是未对齐的。

	其它流水线校正：一些指令(比如使用整数乘法单元的指令)在一些老的CPU上还有
	些额外的限制。如果你用的是这些老的CPU，就会发现汇编器能帮上忙。

	如果想要将汇编源代码与内存中的指令对应起来，需要借助反汇编工具。
	(反汇编：把执行文件，反汇编成汇编语言)
--------------------------------------------------------------------------------
MIPS I到MIPS64 ISA：64位和其他的扩展:
											??怎么扩展的？寄存器位数，寻址，指令变化。
运行在MIPS32兼容状态下时，寄存器的高32位应该存放什么?
--------------------------------------------------------------------------------
基本地址空间：
	在MIPS CPU里，程序中的地址绝不会和芯片的物理地址相同(有时变化很小，但并不
	相同).我们分别称之为程序地址和物理地址。
	MIPS CPU可以运行在两种特权级之一上：用户模式和核心模式，就是用户态和核心
	态。但是MIPS体系结构的一个特点就是从核心态到用户态的变化并不改变操作的行
	为，只是又是某些操作被认为是非法的。在用户态，地址最高位为一的任何程序地
	址都是非法的并会导致自陷。

在32位下：程序地址空间划分为四大区域，每个区域有一个传统的(完全没有意义的)名字。
	根据地址所处的区域不同，处理也不同：
		 ------------------------
                | Mapped         (kseg2) |   1 GB
                |                        | 
0xc000 0000	 ------------------------
                |Unmapped uncached(kseg1)|   512MB
0xa000 0000	 ------------------------
                | Unmapped cached(kseg0) |   512 MB
0x8000 0000	 ------------------------
                | 32-bit userspace kuseg |   
                |                        |   2 GB
                |                        |   
                |                        |   
0x0000 0000	 ------------------------

kuseg 0x0000 0000 - 0x7fff ffff(低端2G):这些地址是用户态可用的地址。在有MMU的机器
	里，这些地址将一概被转换。除非MMU已经设置好，否则不应该使用这些地址，对于
	没有MMU的机器，这些地址的行为与具体实现机器相关。
kseg0 0x8000 0000 - 0x9fff ffff(512M):只要把最高位清零这些地址就会转换成物理地址,
	映射到连续的低端512MB的物理地址。因为这种转换极为简单，常常称这段地址为"
	非转换"的区域，但其实不然。该区域的地址几乎总是要通过高速缓存来获取，所以
	在高速缓存适当初始化之前，不能使用。这个区域在无MMU的系统中用来存放大多数
	程序和数据，再有MMU的系统中用来存放操作系统核心。
kseg1 0xa000 0000 - 0xbfff ffff(512MB):这些地址通过把最高三位清零的方法来映射到物
	理地址，重复映射到了低端512M的物理地址。但是这一次不经过高速缓存。
	kseg1是唯一的在系统重启时能正常工作的地址空间。这也是为什么复位时的入口点
	(0xbfc0 0000)放在这个区域。入口点相应的物理地址是0x1fc0 0000.把入口点地址
	置为0xbfc0 0000是无法启动的。这个区域去存取初始的程序rom，最好不要把这些
	东西映射到物理内存的低512空间之外。
kseg2 0xc000 0000 - 0xffff ffff(1G):这块区域只能在核心态下使用并且要经过MMU的转换。
	在MMU设置好之前，不要存取该区域。除非你在写一个真正的操作系统，否则来说没
	有理由用kseg2.
---------------------------------------------------------------------------------------------------------------------------------------
简单系统的寻址：
	mips的程序地址从来不会和物理地址简单相等。但对于简单的嵌入式软件而言可能
	只用到kseg0和kseg1的地址，他们和物理地址有着非常简单的映射关系。
	从0x2000 0000(512 M)开始向上的物理地址空间在上述简单情形下没有任何的映射，
	大多数简单的系统所有地址都映射到512M以下。但是如果真的需要，你可一通过设
	置存储器管理单元的(TLB)的方式，或者使用64位CPU的一些额外空间，来存取512M
	以上的物理地址。
--------------------------------------------------------------------------------
核心与用户特权级：


--------------------------------------------------------------------------------
64位的地址映射：
	MIPS地址总是通过一个寄存器的值加上一个16位的偏移量形成的。在64位MIPS CPU
	里，寄存器中总是64位的值，因此就有64位的程序地址。
0xffff ffff ffff ffff___ --------------------------
0xffff ffff e000 0000   | supervisor mapped(kseg2) |
                        | kernel                   |
0xffff ffff c000 0000	 --------------------------
0xffff ffff a000 0000   | "unmapped" cached(kseg1) |
                        | "unmapped" cached(kseg0) |
0xffff ffff 8000 0000	 --------------------------	__________________
0xc000 00ff ffff ffff   | _ _ _ _ _ _ _ _ _ _ _ _  |
	xkseg           | kernel-accessible   2^40 |
                        | byte or more             |
0xc000 0000 0000 0000___ --------------------------
                        | -                      - |
                        | window on  physical  mem |
0x9800 0000 0000 0000   | (uncached)               |
                        | -                      - |
	xkphys		 --------------------------
                        | window on  physical  mem |    Inaccessible with 32-bit
                        | (cached)                 |    pointers(so only found in
0x9000 0000 0000 0000 	 --------------------------     64-bit CPUs)
0x8000 0000 0000 0000___| - 	                 - |
0x7fff ffff ffff ffff	 --------------------------
                        | - 	                 - |
	xsseg		 --------------------------
                        | supervisor    accessible |
0x4000 0000 0000 0000   | 2^40 byte or more        |
0x3fff ffff ffff ffff___ --------------------------
                        | - 	                 - |
			 --------------------------
	xuseg           | more      user     space |
                        | to 2^40 byte or more     |
			 --------------------------	____________________
                        | 32-bit user space(kuseg) |
                        | 2 Gbytes                 |
0x0000 0000 0000 0000___ --------------------------
————————————————————————————————————————————————————————————————————————————————
流水线可见性：
	指令遇险:
	前一个CP0操作可能会影响后一个指令的取指的情形，称之为指令遇险(instructi-
	on hazard);
	执行遇险，遇险防护

协处理器0：MIPS处理器控制
	除了通常的运算功能之外，任何处理器都需要一些部件来处理中断、配置选项以及
	需要某种机制来监控诸如片上高速缓存(cache)和定时器等功能。
	CP0作用：
	CPU配置、高速缓存控制、异常/中断控制、存储管理单元控制、杂项。
	k0,k1(通用寄存器$26-27)，只是两个(由软件约定)预留下来的用户异常处理代码中
	通用寄存器。预留至少一个通用寄存器是必要的。
		MIPS CPU 控制寄存器
	寄存器助记符	cp0寄存器编号	描述
	SR		12		状态寄存器(status register)，由可写的控制
					位域(一反常规)组成。包括确定cpu特权等级、
					那些终端引脚使能和其它的CPU模式等位域。
	cause		13		导致异常或中断的原因
	...
	
	CPU控制指令：
	mtc0 	s, <n> #把数据传送到协处理器0
	把cpu通用寄存器s的内容传送到协处理器0寄存器n，数据为32位(即使在64位cpu里，
	很多CP0寄存器也只有32位长，但对于少数长于cp0寄存器有一条dmtc0指令).这是
	设置cpu控制寄存器的唯一方法。

	在汇编程序里直接引用控制寄存器的编号来是不良习惯；通常应该使用助记符。大
	多数工具链把这些名字定义在一个C风格的include文件中，然后用c的预处理作为
	汇编器的前端。

	从CP0控制寄存器中取出数据与之相反：
	mfc0	d, <n> #从协处理器0取出数据
	通用寄存器d装入CPU控制寄存器n的值。这是查看控制寄存器值的唯一方法(类似
	也有dmfc0用于少数64位宽的寄存器)
	通常要更新控制寄存器内部的单个域---如SR状态寄存器，通常代码是这个：
	mfc0	t0, SR
	and	t0, <要清零的位的反码>
	or	t0, <要置1的位>
	mtc0	SR, t0

	异常基本问题:
	异常可以在运行用户(低特权级)代码是发生，但是异常处理运行在高特权级。因此	软件异常，系统调用
	一：如果在控制返回用户程序之前特权级就降低了，马上就会因为违反特权级而得
	到一个致命的二次异常；二：如果在降低特权级之前先回到用户代码，那么一个恶
	意的无特权的程序就有可能得到机会以内核特权级运行一条指令。
	eret来完成特权级切换的任务。

3.2控制寄存器的使用
	上电后：需要设置SR来使CPU进入一个可工作的状态，以便能够顺利执行随后的引
	导过程。硬件通常的做法都是在复位后让许多寄存器的位为未定义。

	处理任意异常：早期的MIPS cpu中任何异常都调用一个固定入口地址的公共的“通
	用异常处理程序”。后来有越来越多的理由支持对不同的目的使用分开的异常处理
	程序。
	在异常入口处，不报存任何程序寄存器，只有返回地址被存在EPC。MIPS硬件队于
	堆栈一无所知。在任何情况下一个安全操作系统拥有特权的异常处理程序不能假定
	用户级代码的正确性————特别地，它不能假定栈指针有效或者栈空间可用。

	从异常返回：控制最终必须返回到在异常入口处保存到EPC中的地址。不管是什么
	异常，返回时都要把SR寄存器调整回原来的值、恢复用户态特权，允许中断以及消
	除异常的一般影响。最后异常返回返回指令eret合并完成了返回用户空间和复位S
	R（EXL）的功能。

	中断：SR用来调整中断掩码，决定那些中断被赋予比当前更高的优先级。硬件没有
	提供中断优先级，但是软件可以随意。 
	纯粹为了引发异常的指令：这些指令常用于（系统调用、断点调试以及某些指令仿
	真等）。所有的MIPS CPU都实现了break和syscall指令；有些实现还加了额外的指
	令。
3.3CPU控制寄存器及其编码
状态寄存器SR：
	MIPS CPU仅有的几个模式位定义在高度紧凑的状态寄存器SR的域中。
	31   28 27 26 25 24 23 22  21 20  19  18 17 16 15   10 9  8  7  6  5  4  3  2   1   0
	CU3-0   RP FR RE MX PX BEV TS SR  NMI 0  Impl  IP7 -2 IP1-0  KX SX UX  UM R0 ERL EXL IE
							IPL		    KSU

	CU3-0: 每个位分别代表协处理器3-0的协处理器使能。
	RP: 减小功耗，可以减低CPU的运行频率、电压或者同时减低。
	FR: 模式切换设为1则全部32个双倍宽度的浮点寄存器软件都可见；设为0让他们模
	    拟MIPS I的成对32位浮点寄存器的行为。
	RE: 反转用户态下的尾端设置。
	
	BEV:启动时异常向量
	TS:TLB关闭

	UX,SX,KX:三个不同的（用户、管理、核心）特权级各自有不同的位。当相应位置位
		后最为常见的内存地址转换异常(TLB未命中)被重定向到不同的入口点，在
		那里软件将处理64位地址。
	KSU:CPU特权级0是核心级，1是管理级，2是用户级。

	ERL:错误级
		ERL赋予了一个特殊的任务，一旦其置位，就会深度影响处理器的行为；对
		正常的用户空间转换的地址的所有访问都将消失，从0到0x7fff ffff的程序
		地址变成一个映射到相同物理地址的不做高速缓存的窗口。

3.3.2 原因寄存器（Cause）
	BD 分支延迟：
	EPC保存的是异常处理完后的返回地址，正常情况下，这也指向异常受害指令。
	但是如果发生异常的指令实在一条转移指令的延迟槽里，EPC得指向那条转移指令；
	重新执行转移指令没有什么害处，但如果返回到延迟槽指令本身，转移就不会发生
	从而这个异常将破坏背中断的程序。
	只要异常发生在延迟槽的指令，cause(BD)就会置位,EPC就指向指令分支。如果想分
	析异常受害指令，只要看cause(BD)(如果cause(BD)==1，那么该指令位于EPC+4）就
	知道了。
















	








MIPS高速缓存工作机制
直接映射缓存，组相联缓存
---------------------------------------------------------------------------------------------------------------------------------------
异常、中断及初始化

外部事件：在CPU核之外的事件——即来自于真实的“连线”上的输入信号。

存储器地址转换异常：当某个地址需要转换但是硬件不能有效转换时，或当写个有写保护的页时，会发生这个异常。
