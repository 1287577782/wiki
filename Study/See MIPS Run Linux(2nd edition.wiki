MIPS五级流水线：
	IF(instruction fetch)-->RD(read register)-->ALU(arithmetic/logic unit)-->MEM(mem)-->WB(write back)
MIPS所有的指令长度都是32位，MIPS的二进制文件比典型的80*86大百分之二十到三十。但是不可能把一个32位常数放进单个指令中。
MIPS留出26位常数的空间用以编码跳转和调用指令的目标地址，这样的指令只有两条。其他指令只能有16位空间留给常数。
MIPS指令的最小操作码域为6位，留出了26位来定义跳转的目标，因为所有指令在内存中都是四字节边界对齐的，低两位无需保存，这样可有2^28=256MB的地址范围(段内绝对地址).
条件分支只有16位的偏移域---给出了2^18字节的范围，因为指令都是四字节对齐的。
四字节对齐 ： 内存中是四字节对齐是说只需要指向四字节的第一个地址就OK了，向下偏移，而且一位地址指向8bits的内存长度。

没有条件码，MIPS的条件分支只测试单个寄存器的符号/为零或者一对寄存器是否相等。

寻址和访存:
访问内存只能通过简单的寄存器加载和存储:每次内存访问都要一条显式的加载或存储指令。

只有一种数据寻址方式:几乎所有的加载和存储都通过单个寄存器基址加上一个16位的常数偏移量寻址内存。

字节地址指令:一旦数据存入MIPS CPU的寄存器，所有的操作都是在整个寄存器上操作。但是像C这样的语言语义不适合不能寻址内存到字节粒度的机器。因而MIPS对8-和16-位变量(分别称为字节和办字)提供了一套完整的装入/存储操作。一旦数据到达寄存器，就当作寄存器全长来处理，所以部分字加载指令有两种形式——符号扩展和零扩展。
??:那内存中是怎么存储和扩展的

load/store必须对齐:内存操作只能对齐到相应数据类型边界的地址加载和存储数据。字节可以在任意地址传输，但是半字必须在偶数地址对齐，字在四字节边界对齐。许多CISC微处理器可以从任意字节地址加载/存储四字节数据，但是要花费额外的时钟周期。

跳转指令:有限的32位指令长度想要支持很大程序的体系结构上对分支是个问题。MIPS指令的最小操作码域为6位，留出了26位来定义跳转的目标。因为所有指令在内存中都是四字节对齐边界的，低两位地址无需保存，这样有2^28=256MB的地址范围。这个地址不是相对PC的，而是解释成256MB段内的绝对地址。这对于大于256MB的单个程序极为不便。
超出段内的分支可以通过使用一个寄存器跳转指令做到，该指令可以跳到任意32位地址。
条件分支只有16位的偏移域——给出了2^18字节的范围，因为指令都是四字节对齐的——解释成相对PC的带符号的偏移量。如果知道分支目标会在紧跟分支之后的指令的128KB范围内，编译器就能只生成一个简单的条件分支指令。

MIPS没有的特性：
没有字节或半字数据的运算：所有算术和逻辑操作都是在32位的数据上进行。字节或半字的运算需要大量额外的资源和许多额外的操作码，而且很少有用。C语言的语法让大多数的计算用int类型，对MIPS而言int就是32位的整数。然而当程序明确做short或者char运算时，MIPS编译器必须插入额外的代码以保证结果回绕和溢出，生成跟16-或8-位机器上一样的结果。

没有对堆栈的特殊支持：传统MIPS汇编确实定义一个寄存器作为堆栈指针，但是硬件上SP没有任何特殊之处。有一种推荐的关于子程序调用的栈帧布局，这样可以混合不同语言和编译器的模块；你应当遵守这些约定，但是这些与硬件无关。堆栈弹出不能适应流水线，因为有两个寄存器要写（来自堆栈的数据和增加指针值）。

最少的子程序支持：有一点比较特别，跳转指令有一个跳转并连接的选项，把返回地址存入一个寄存器，默认是$31.所以习惯上用31作为返回地址寄存器.这样做比起把返回地址保存到堆栈上要简单，但却带来明显的好处。第一保持了分支和访存指令的完全分离；第二，当调用许多根本不需要在堆栈保存返回地址的小程序时，这样有助于提高效率。

最少的中断处理：
最少的异常处理：

流水：
	延迟分支
	数据加载延迟 

第2章	MIPS体系结构
计算机也是如此——如果你有某种极端的或者超常规的需求，实现的细节就对你很重要了。
一般而言，一个CPU的体系结构包括一组指令集加上一些寄存器的知识。指令集与体系结构这两个术语基本上是同义词。ISA(Instruction Set Architeture指令集体系结构)。

寄存器：
	0	zero	永远返回0
	1	at	(assembly temporary汇编暂存)保留给汇编器使用
	2-3	v0,v1	子程序返回值
	4-7	a0-a3	(arguments)子程序调用的前几个参数
	8-15	t0-t7	(temporaries)临时变量，子程序使用时无需保存
	24-25	t8-t9	
	16-25	s0-s7	子程序寄存器变量；子程序写入时必须保存其值并返回前恢复原值，从而调用函数看到这些寄存器的值没有变化。
	26-27	k0,k1	保留给中断或自陷处理程序使用；其值可能在你眼皮地下改变
	28	gp	(global pointer)全局指针；一些运行系统维护这个指针以便于存取static和extern变量.
	29	sp	(stack pointer)堆栈指针
	30	s8/fp	第九个寄存器变量；需要的子程序可以用来做帧指针(frame pointer)
	31	ra	子程序的返回地址
s0-s8:依照约定，必须保证这些寄存器的内容在子程序返回时要和子程序入口时的值相同，要么在子程序里不用这些寄存器，要么把它们保存在堆栈上并在子程序返回时恢复。这种约定使得这些寄存器非常适合作为寄存器变量，或存放一些在子程序调用期间必须保存的值。

k0,k1:保留给操作系统的自陷/中断处理程序使用；用完后不必恢复原来的值；很少用于其它用途。

gp:用于两个不同目的。对于linux程序使用的一类位置无关的代码PIC，本模块外的代码和数据引用都要通过一个称为全局偏移量表GOT(global offset table)的指针表。gp寄存器用来维护指向该表的指针。
在常规的非PIC代码(在简单的嵌入式系统中会用到)中，gp有时用来指向一个链接时确定位置的静态数据中部。这意味着，利用gp作基指针，对于在gp指针前后32k范围内的数据存取，只需要一条指令就可完成。
如果没有全局指针，存取一个静态数据区域的值需要两条指令：一条是获取由编译器和装载程序计算去的32位地址常量的高位，另外一条才真正存取数据。
要建立相对于gp的地址应用，编译器在编译时刻必须知道一个数据链接后的内存地址在64K范围之内。实际上这是不可能知道的，只能靠猜测。通常的做法是把小的(八字节以内的)全局数据项放在gp的区域内，如果还是太大，就让链接器发出警告。

sp:堆栈指针的上下移动需要显式的通过指令来实现，因此MIPS通常只在子程序入口处把sp调整到子程序中间堆栈可能达到的最低点，从而编译器可以通过相对与sp的固定偏移量来存取堆栈变量。

fp:帧指针，也叫做s8.如果由于某种原因编译器或程序员不能或不愿计算相对于堆栈指针的偏移量，子程序可以通过帧指针来记录/跟踪堆栈的情况。

ra:在任何一个子程序入口处，ra寄存器中保存着返回地址——因此典型的子程序都以一条jr ra指令结尾。理论上讲，这里可以使用任意寄存器，但是一些复杂的CPU因为采用优化技巧(分支预测)，使得jr ra时效果会更好。

整数乘法部件及寄存器 lo hi
因为乘法的结果返回没有快到能自动供随后的指令使用的程度，乘法的结果寄存器总是互锁的。在乘法运算完成之前任何企图读取结果的操作都将导致CPU停下来等待乘法操作结束。
整数乘法器也可以执行两个通用寄存器的除法操作。lo(商),hi(余).
乘法要用4-12个周期，除法要用20-80个周期。

加载与存储：寻址方式
MIPS只有一种寻址方式，任何加载或存储操作的机器指令都可以写成：
{{{	lw $1, offset($2)	
}}}
可以用任何寄存器作为目标和源寄存器。偏移量offset是一个有符号的16位的数字(-32768 32767);加载所用的程序地址是$2寄存器的值与offset的和。这种寻址方式一般已足够存取C语言结构体的一个成员。

寄存器与寄存器的数据类型
long long	dword	8	ld--->d
int		word	4	lw--->w
short		halfword 2	lh--->h
char		byte	1	lb--->b
整数数据类型
字节byte和半字halfword的加载方式有两种。符号扩展的指令lb lh指令将数据值存放在32为寄存器的地位，并将高位用符号位（字节的位7，半字的位15）的值来填充。
无符号的指令lbu和lhu用零来扩展数据，将数据值加载到32为寄存器的地位中，并用零来扩充高位。
例如：假设寄存器t1中是存储器中一个byte字节宽度数据的地址，该处存放的值为0xFE(有符号数-2或无符号数254)，那么
lb	t2, 0(t1)
lbu	t3, 0(t1)
执行之后，寄存器t2的值为0xFFFF FFFE(有符号数-2)，t3的值会是0x0000 00FE(有符号数或无符号数254)

未对齐的加载和存储
MIPS体系结构中，正常的加载和存储必须对齐；半字只能从双字节的边界加载；字只能从四字节的边界加载。一个对非对齐的地址的加载指令会导致自陷.或者按照宏命令（由多个命令组成）。
linux-gcc也会按照类型对齐uint16_t双字节对齐，所以链接后它的地址肯定是2(按字节寻址）的倍数,int是4的倍数。

内存中的浮点数据
l.d	$f2, 24(t1) ==
lwc1	$f2, 24(t1)
lwc1	$f3, 28(t1)
在64为CPU上，任何一个遵循MIPS/SGI规则的C编译器都将八字节长的双精度浮点变量对齐到八字节的地址边界上。32为硬件并没有这样的对齐要求，对齐仅仅是为了向后兼容。

汇编语言的合成指令：
GNU的汇编器会合成一些指令，只需要写一个li(加载立即数)指令，汇编器会知道什么时候要生成两条机器指令。要明确区分合成指令与机器指令。
---------------------------------------------------------------------------------------------------------------------------------------
汇编器所做的：
32位立即数的加载，写一个加载任何值的代码，汇编器将会把其拆开成为两个指令，分别加载这个数据的高半部分和低半部分。

从内存地址加载，写一个加载驻留内存的变量的代码。汇编器通常会将这个替换成两个指令，先是一条把变量地址的高位加载到临时寄存器的指令，接着是一条以改变量的低位为偏移量的加载指令。当然这不适用于C语言函数内部定义的局部变量，局部变量是通过寄存器或堆栈实现的。

对内存变量的快速存取，有些c程序包含许多对static和extern变量的引用，对他们加载/存储用两条指令开销太大了。有些编译系统，在编译/汇编时(最常见的做法是汇编器选择占用八个字节或更小空间的变量)选择一些变量，并将他们一起存放到最后大小在64K字节以内的一个内存区。然后运行时系统初始化一个寄存器——习惯上用$28也就是gp——来指定该内存去的中间位置。
对这些变量数据的加载和存储现在就可以通过一条相对gp寄存器寻址的加载或存储指令来完成。

更多类型的分支条件：汇编器合成了一整套根据两个寄存器的算术运算结果来进行条件分支的指令。

同一指令的简写或多种不同的写法：像not和neg这样的单目运算，时通过与永远是零值的寄存器$0的nor或sub来实现的。你还可以把一个三个操作数的指令写成两个操作数的形式，汇编器将会把结果写道给出的第一个寄存器中

隐藏分支延迟槽：在正常的情况下，汇编器如果看出将写在分支之前的指令移动到延迟槽没问题的话，就会这样做。因为汇编器能够看出的情况不多，所以不太善于填充延迟槽。有一条汇编伪指令.set noreorder可以用来告诉汇编器不要自动移动指令，由程序员人工控制。

隐藏加载延迟槽：有些汇编器会检测到紧接加载指令后试图使用加载结果的指令，如果行的话可能会上下移动一条指令。

未对齐的数据传送：非对齐的加载/存储指令(ulh, ulw等待)能正确的存取半字和字数据，即使目标地址是未对齐的。

其它流水线校正：一些指令(比如使用整数乘法单元的指令)在一些老的CPU上还有些额外的限制。如果你用的是这些老的CPU，就会发现汇编器能帮上忙。
如果想要将汇编源代码与内存中的指令对应起来，需要借助反汇编工具。(反汇编：把执行文件，反汇编成汇编语言)
---------------------------------------------------------------------------------------------------------------------------------------
MIPS I到MIPS64 ISA：64位和其他的扩展:
??怎么扩展的？寄存器位数，寻址，指令变化。
运行在MIPS32兼容状态下时，寄存器的高32位应该存放什么?
最好的方案是将寄存器的高32位与第31位一样。保证每个寄存器存放着正确的低32位值并且高32位是第31位的复制，那么所有的MIPS64比较和测试指令（需要测试寄存器的值是否相等或为负，得查看最高位——31/63位）都与其MIPS32的相应版本兼容.可以这样描述：将寄存器中32位的值符号扩展到64位，这种方法并没有考虑该32位的值是有符号的还是无符号的。
---------------------------------------------------------------------------------------------------------------------------------------
基本地址空间：
在MIPS CPU里，程序中的地址绝不会和芯片的物理地址相同(有时变化很小，但并不相同).我们分别称之为程序地址和物理地址。

MIPS CPU可以运行在两种特权级之一上：用户模式和核心模式，就是用户态和核心态。但是MIPS体系结构的一个特点就是从核心态到用户态的变化并不改变操作的行为，只是又是某些操作被认为是非法的。在用户态，地址最高位为一的任何程序地址都是非法的并会导致自陷。

在32位下：程序地址空间划分为四大区域，每个区域有一个传统的(完全没有意义的)名字。根据地址所处的区域不同，处理也不同：
		 ------------------------
                | Mapped         (kseg2) |   1 GB
                |                        | 
0xc000 0000	 ------------------------
                |Unmapped uncached(kseg1)|   512MB
0xa000 0000	 ------------------------
                | Unmapped cached(kseg0) |   512 MB
0x8000 0000	 ------------------------
                | 32-bit userspace kuseg |   
                |                        |   2 GB
                |                        |   
                |                        |   
0x0000 0000	 ------------------------

kuseg 0x0000 0000 - 0x7fff ffff(低端2G):这些地址是用户态可用的地址。在有MMU的机器里，这些地址将一概被转换。除非MMU已经设置好，否则不应该使用这些地址，对于没有MMU的机器，这些地址的行为与具体实现机器相关。

kseg0 0x8000 0000 - 0x9fff ffff(512M):只要把最高位清零这些地址就会转换成物理地址，映射到连续的低端512MB的物理地址。因为这种转换极为简单，常常称这段地址为"非转换"的区域，但其实不然。
	该区域的地址几乎总是要通过高速缓存来获取，所以在高速缓存适当初始化之前，不能使用。这个区域在无MMU的系统中用来存放大多数程序和数据，再有MMU的系统中用来存放操作系统核心。

kseg1 0xa000 0000 - 0xbfff ffff(512MB):这些地址通过把最高三位清零的方法来映射到物理地址，重复映射到了低端512M的物理地址。但是这一次不经过高速缓存。
	kseg1是唯一的在系统重启时能正常工作的地址空间。这也是为什么复位时的入口点(0xbfc0 0000)放在这个区域。入口点相应的物理地址是0x1fc0 0000.把入口点地址置为0xbfc0 0000是无法启动的。这个区域去存取初始的程序rom，最好不要把这些东西映射到物理内存的低512空间之外。

kseg2 0xc000 0000 - 0xffff ffff(1G):这块区域只能在核心态下使用并且要经过MMU的转换。在MMU设置好之前，不要存取该区域。除非你在写一个真正的操作系统，否则来说没有理由用kseg2.
---------------------------------------------------------------------------------------------------------------------------------------
简单系统的寻址：
	mips的程序地址从来不会和物理地址简单相等。但对于简单的嵌入式软件而言可能只用到kseg0和kseg1的地址，他们和物理地址有着非常简单的映射关系。
	从0x2000 0000(512 M)开始向上的物理地址空间在上述简单情形下没有任何的映射，大多数简单的系统所有地址都映射到512M以下。但是如果真的需要，你可一通过设置存储器管理单元的(TLB)的方式，或者使用64位CPU的一些额外空间，来存取512M以上的物理地址。
---------------------------------------------------------------------------------------------------------------------------------------
核心与用户特权级：


---------------------------------------------------------------------------------------------------------------------------------------
64位的地址映射：
	MIPS地址总是通过一个寄存器的值加上一个16位的偏移量形成的。在64位MIPS CPU里，寄存器中总是64位的值，因此就有64位的程序地址。
0xffff ffff ffff ffff___ --------------------------
0xffff ffff e000 0000   | supervisor mapped(kseg2) |
                        | kernel                   |
0xffff ffff c000 0000	 --------------------------
0xffff ffff a000 0000   | "unmapped" cached(kseg1) |
                        | "unmapped" cached(kseg0) |
0xffff ffff 8000 0000	 --------------------------	__________________
0xc000 00ff ffff ffff   | _ _ _ _ _ _ _ _ _ _ _ _  |
	xkseg           | kernel-accessible   2^40 |
                        | byte or more             |
0xc000 0000 0000 0000___ --------------------------
                        | -                      - |
                        | window on  physical  mem |
0x9800 0000 0000 0000   | (uncached)               |
                        | -                      - |
	xkphys		 --------------------------
                        | window on  physical  mem |    Inaccessible with 32-bit
                        | (cached)                 |    pointers(so only found in
0x9000 0000 0000 0000 	 --------------------------     64-bit CPUs)
0x8000 0000 0000 0000___| - 	                 - |
0x7fff ffff ffff ffff	 --------------------------
                        | - 	                 - |
	xsseg		 --------------------------
                        | supervisor    accessible |
0x4000 0000 0000 0000   | 2^40 byte or more        |
0x3fff ffff ffff ffff___ --------------------------
                        | - 	                 - |
			 --------------------------
	xuseg           | more      user     space |
                        | to 2^40 byte or more     |
			 --------------------------	____________________
                        | 32-bit user space(kuseg) |
                        | 2 Gbytes                 |
0x0000 0000 0000 0000___ --------------------------
---------------------------------------------------------------------------------------------------------------------------------------
流水线可见性：
	指令遇险，执行遇险，遇险防护
---------------------------------------------------------------------------------------------------------------------------------------
协处理器0：MIPS处理器控制
	除了通常的运算功能之外，任何处理器都需要一些部件来处理中断、配置选项以及需要某种机制来监控诸如片上高速缓存(cache)和定时器等功能。ISA对运算指令集的处理方式很好，做到了与实现无关；但是对处理器控制...

CP0作用：
CPU配置、高速缓存控制、异常/中断控制、存储管理单元控制、杂项。
---------------------------------------------------------------------------------------------------------------------------------------
MIPS高速缓存工作机制
直接映射缓存，组相联缓存
---------------------------------------------------------------------------------------------------------------------------------------
异常、中断及初始化

外部事件：在CPU核之外的事件——即来自于真实的“连线”上的输入信号。

存储器地址转换异常：当某个地址需要转换但是硬件不能有效转换时，或当写个有写保护的页时，会发生这个异常。
