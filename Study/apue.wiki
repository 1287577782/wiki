标准I/O
opendir	getc	putc 	read	write	ferrorr	getpid	execlp	fprintf	strerror
perror

限制：
	1) 编译时限制
	2) 不与文件或目录相关联的运行时限制（sysconf函数）。
	3) 与文件或目录相关联的运行时限制（pathconf和fpathconf函数）。

文件I/O
	对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负
	整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述
	符。
	open()
	int open(const char *pathname, int oflag, .../- mode -/);

	oflag:
		O_RDONLY	0
		O_WRONLY	1
		O_RDWR		2

3.3 顺序执行下面3个函数调用
	fd1 = open(pathname, oflags);
	fd2 = dup(fd1);
	fd3 = open(pathname, oflags);

	open 会新建文件描述符，文件表项,指向同一个v节点。
	dup 新建一个新的文件描述符，但是指向上面一个文件表项。

4.
	stat函数返回与此命名文件有关的信息结构。
	fstat函数获取已在描述副filedes上打开文件的有关信息。
	lstat函数类似于stat，但是当命名的文件是一个符号链接时
文件类型
	1. 普通文件
	普通文件(regular file)。至于这种数据是文本还是二进制数据对于UNIX内核而言
	并无区别。对普通文件内容的解释由处理该文件的应用程序进行。

	2. 目录文件(directory file)
	这种文件包含了其他文件的名字以及指向与这些文件有信息的指针。对一个目录文
	件具有读权限的任一进程都可以度该目录的内容，但只有内核可以直接写目录文件

	3. 块特殊文件(block special file)
	这种文件类型提供设备（例如磁盘）带缓冲的访问，每次访问以固定长度为单位进
	行。

	4. 字符特殊文件(character special file)
	这种文件类型提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备	系统的所有设备要么是字符特殊文件，要么是块特殊
	要么是字符特殊文件，也么是块特殊文件。						文件。

	5. FIFO
	用于进程间通信，有时也将其称为命名管道(named pipe)。

	6. 套接字(socket)
	用于进程间的网络通信。套接字也可用于在一台宿主上进程之间的非网络通信。

	7. 符号连接(symbolic link)
	指向另一个文件。

	文件类型信息包含在stat结构的st_mode成员中。

POSIX.1允许实现将进程间通信(IPC)对象（例如，消息队列，信号量，共享内存等）表示为
文件。

4.4 与一个进程相关联的ID有6个或更多
	--------------------------------------
	实际用户ID	我们实际上是谁							实际用户ID，就是当前执行这个进程的用户ID。
	实际组ID
	--------------------------------------
	有效用户ID	用于文件访问权限检查						比如passwd 程序，一个用户修改自己的密码是正常的
	有效组ID									但是保存密码的文件/etc/passwd却是root用户可写的
	附加组ID									必须通过root用户修改。这时os把有效ID变成拥有
											passwd的用户的ID，就是root。
	--------------------------------------
	保存的设置用户ID	由exec函数保存
	保存的设置组ID
	--------------------------------------

	通常有效ID等于实际用户ID，有效组ID等于实际组ID。

	每个文件都有一个所有者和组所有者，所有者由stat结构中st_uid成员表示，组所
	有者则由st_gid成员表示。

	当用户执行一个具有超级权限的进程文件时候，将获得额外的超级权限，这时候要
	设置用户ID特征。

相对与文件来说的：
	set-user-ID,设置用户ID。设置了set-user-ID 位的可执行程序，执行时，进程的
	effective user ID与saved set-user-ID都为程序文件所属用户的ID，这是read-
	user-ID与effective-user-ID就不一定相等了。这类程序称之为SUID。例如，pas-
	swd ping等。

	对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在
	该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部
	分时，对该目录的执行权限使我们可通过该目录，也就是搜索该目录，寻找一个特
	定的文件名。

	对于一个文件的读权限决定了我们是否能够打开该文件进行读操作。这与open函数
	的O_RDONLY和O_RDWR标志相关。

	对于一个文件的写权限决定了我们是否能够打开该文件进行写操作。这与open函数
	的O_WRONLY和O_RDWR标志相关。

	进程每次打开、创建或者删除一个文件时，内核就进行文件访问权限测试，而这种
	测试可能涉及文件的所有者(st_uid,st_gid)、进程的有效ID（有效用户ID 和有效
	组ID）以及进程的附加组ID。两个所有者ID是文件的性质，而两个有效ID和附加组
	ID则是进程的性质。

新文件和目录的所有权
	新文件的用户ID设置位进程的有效用户ID。
	(1)新文件的组ID可以是进程的有效组ID。
	(2)新文件的组ID可以是它所在目录的组ID。

access函数
	当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其
	访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能力。
	例如，当一个进程使用设置用户ID或设置组ID特征作为另一个用户（或组）运行时
	就可能会有这种需要。即使一个进程可能已经因设置用户ID以超级用户权限运行，
	他仍可能想验证其实际用户能否访问一个给定的文件。access函数是按实际用户ID
	和实际组ID进行访问权限测试。

umask:
	先设置umask位，在create函数时，会掩掉，mode_t参数的设置。

int chown(const char *pathname, uit_t owner, git_t group);
int fchown(int files, uit_t owner, git_t group);
int lchown(const char *pathname, uit_t owner, git_t group);
	_POSIX_CHOWN_RESTRICTED:
	可以用pathconf fpathconf函数查询。若_POSIX_CHOWN_RESTRICTED对指定的文件
	起作用。则：
	(1) 只有超级用户进程能更改该文件的用户ID。
	(2) 若满足下列条件，一个非超级用户进程就可以更改该文件的组ID：
		a)进程拥有此文件(其有效用户ID等于该文件的用户ID)。
		b)参数owner等于-1或文件的用户ID，并且参数group等于进程有效组ID
		  或进程的附加组ID之一。
	这意味着，当_POSIX_CHOWN_RESTRICTED 起作用时，不能更改其他用户文件的用
	户ID，但只能改到你所属的组。

	如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位	这句话的讲的什么意思??
	和设置组ID位都会被清除。

文件长度：
	stat结构成员st_size 表示以字节为单位的字节长度。此字段只对普通文件、目	stat结构，存在那个地方，怎么和文件进行关联??
	录文件和符号链接有意义。							stat结构中的大多数信息都取自i节点，只有两项
											数据存放在目录项中。
	对于目录，文件长度通常是一个数(例如16或512)的倍数。
	对于符号链接，文件长度是文件名中的实际字节数。				就是指向的文件的文件名的长度，不包含结尾的null。

标准I/O：
	标准I/O库，它们的操作是围绕流的，在第3章中所有I/O 函数都是针对文件描述
	符的。当用标准I/O 打开或创建一个文件时，已使一个流与一个文件相关联。可
	以对一个流调用fileno函数以获得其描述符。

FILE对象是如何定义的、每个流标志的定义以及定义为宏的各个标准I/O例程...

系统数据文件和信息：
	用户每次登录UNIX系统以及每次执行ls -l命令时都要使用口令文件。

口令文件：
	为阻止一个特定用户登录系统，除使用/dev/null之外，还有若干种替代方法。
	一种常见的方法是，将/bin/false用作登录shell。
组文件：
	/etc/group	
登录账户记录：
	大多数UNIX系统都提供两个数据文件：utmp文件，它记录当前登进系统的各个用
	户；wtmp文件，它跟踪各个登录和注销事件。

进程环境：
	当内核执行C程序时（使用一个exec函数，8.10），在调用main 前先调用一个特
	殊的启动例程。可执行程序文件将此启动例程指定为程序的其实地址，这是由连
	接编辑器设置的。启动例程从内核取得命令行参数和环境变量值。

有八种方式使进程终止(termination)，其中5种为正常终止：
	1). 从main返回
	2). 调用exit
	3). 调用_exit或_Exit
	4). 最后一个线程从启动例程返回
	5). 最后一个线程调用pthread_exit
异常终止：
	6). 调用abort
	7). 接到一个信号并终止
	8). 最后一个线程对取消请求作出响应

exit函数总是执行一个标准I/O库的清理关闭操作：为所有打开流调用fclose 函数。造成
所有缓冲的数据都被冲洗（写到文件上）。

exit,return区别


测试程序是否使用共享库：
	cc -static hello1.c	组织gcc是使用共享库

错误： 释放一个已经释放的块；调用free时所用的指针不是3个alloc函数的返回值。

如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储器就会连
续增加，这被称为泄漏(leakage)。

环境变量，更改现有的name，或者增加新的，有的需要malloc空间。

setjmp	longjmp

每个进程的都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
进程的资源限制通常是在系统初始化时由进程0 建立的，然后由每个后续进程继承。每种
实现都可以用自己的方法对各种限制作出调整。

进程ID是唯一的，但是进程ID可以重用。当一个进程终止后，其进程ID就可以再次使用了
大多数UNIX系统实现延迟重用算法，使得赋予新建进程的ID不同于最近终止进程所使用的
ID。

ID位0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分
它并不执行任何磁盘上的程序，因为也被称为系统进程。

由fork创建的新进程被称为子进程（child process）。fork 函数被调用一次，但返回两
次。两次返回的唯一区别是子进程的返回值是0 ，而父进程的返回值则是新子进程的进程
ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一
个函数是一个进程可以获得其所有子进程的进程ID。fork使子进程得到返回值0 的理由是
一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID	进程ID 0总是由内核交换进程使用，所以一个子进程的
	pit_t fork(void);							进程ID不可能是0
子进程和父进程继续执行fork调用之后的指令。子进程是父进程副本
