标准I/O: opendir	getc	putc 	read	write	ferrorr	getpid	execlp	fprintf	strerror perror

限制：
# 编译时限制
# 不与文件或目录相关联的运行时限制（sysconf函数）。
# 与文件或目录相关联的运行时限制（pathconf和fpathconf函数）。

文件I/O: 对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。
```    
    open()
    int open(const char *pathname, int oflag, .../- mode -/);
    
    oflag:
    O_RDONLY	0
    O_WRONLY	1
    O_RDWR	2
```

3.3 顺序执行下面3个函数调用
```
    
    fd1 = open(pathname, oflags);
    fd2 = dup(fd1);
    fd3 = open(pathname, oflags);
    
```
* open 会新建文件描述符，文件表项,指向同一个v节点。
* dup 新建一个新的文件描述符，但是指向上面一个文件表项。


* stat函数返回与此命名文件有关的信息结构。
* stat函数获取已在描述副filedes上打开文件的有关信息。
* stat函数类似于stat，但是当命名的文件是一个符号链接时

文件类型:
* 普通文件(regular file) 至于这种数据是文本还是二进制数据对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。
* 目录文件(directory file) 这种文件包含了其他文件的名字以及指向与这些文件有信息的指针。对一个目录文件具有读权限的任一进程都可以度该目录的内容，但只有内核可以直接写目录文件
* 块特殊文件(block special file) 这种文件类型提供设备（例如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。
* 字符特殊文件(character special file) 这种文件类型提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备系统的所有设备要么是字符特殊文件，要么是块特殊文件。
* FIFO 用于进程间通信，有时也将其称为命名管道(named pipe)。
* 套接字(socket) 用于进程间的网络通信。套接字也可用于在一台宿主上进程之间的非网络通信。
* 符号连接(symbolic link) 指向另一个文件。

文件类型信息包含在stat结构的st_mode成员中。

POSIX.1允许实现将进程间通信(IPC)对象（例如，消息队列，信号量，共享内存等）表示为文件。

4.4 与一个进程相关联的ID有6个或更多
    --------------------------------------
    实际用户ID	我们实际上是谁					实际用户ID，就是当前执行这个进程的用户ID。
    实际组ID
    --------------------------------------
    有效用户ID	用于文件访问权限检查				比如passwd 程序，一个用户修改自己的密码是正常的
    有效组ID							但是保存密码的文件/etc/passwd却是root用户可写的
    附加组ID							必须通过root用户修改。这时os把有效ID变成拥有
    								passwd的用户的ID，就是root。
    --------------------------------------
    保存的设置用户ID	由exec函数保存
    保存的设置组ID
    --------------------------------------
通常有效ID等于实际用户ID，有效组ID等于实际组ID。

每个文件都有一个所有者和组所有者，所有者由stat结构中st_uid成员表示，组所有者则由st_gid成员表示。

当用户执行一个具有超级权限的进程文件时候，将获得额外的超级权限，这时候要设置用户ID特征。

相对与文件来说的：set-user-ID,设置用户ID。设置了set-user-ID 位的可执行程序，执行时，进程的 effective user ID与saved set-user-ID都为程序文件所属用户的ID，这是read-user-ID与effective-user-ID就不一定相等了。这类程序称之为SUID。例如，passwd ping等。

对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可通过该目录，也就是搜索该目录，寻找一个特定的文件名。

对于一个文件的读权限决定了我们是否能够打开该文件进行读操作。这与open函数的O_RDONLY和O_RDWR标志相关。

对于一个文件的写权限决定了我们是否能够打开该文件进行写操作。这与open函数的O_WRONLY和O_RDWR标志相关。

进程每次打开、创建或者删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉及文件的所有者(st_uid,st_gid)、进程的有效ID（有效用户ID 和有效组ID）以及进程的附加组ID。两个所有者ID是文件的性质，而两个有效ID和附加组ID则是进程的性质。

新文件和目录的所有权
* 新文件的用户ID设置位进程的有效用户ID。
* 新文件的组ID可以是进程的有效组ID。
* 新文件的组ID可以是它所在目录的组ID。

access函数: 当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能力。例如，当一个进程使用设置用户ID或设置组ID特征作为另一个用户（或组）运行时就可能会有这种需要。即使一个进程可能已经因设置用户ID以超级用户权限运行，他仍可能想验证其实际用户能否访问一个给定的文件。access函数是按实际用户ID和实际组ID进行访问权限测试。 

umask: 先设置umask位，在create函数时，会掩掉，mode_t参数的设置。
```
    int chown(const char *pathname, uit_t owner, git_t group);
    int fchown(int files, uit_t owner, git_t group);
    int lchown(const char *pathname, uit_t owner, git_t group);
```
_POSIX_CHOWN_RESTRICTED:
	可以用pathconf fpathconf函数查询。若_POSIX_CHOWN_RESTRICTED对指定的文件
	起作用。则：
	(1) 只有超级用户进程能更改该文件的用户ID。
	(2) 若满足下列条件，一个非超级用户进程就可以更改该文件的组ID：
		a)进程拥有此文件(其有效用户ID等于该文件的用户ID)。
		b)参数owner等于-1或文件的用户ID，并且参数group等于进程有效组ID
		  或进程的附加组ID之一。
	这意味着，当_POSIX_CHOWN_RESTRICTED 起作用时，不能更改其他用户文件的用
	户ID，但只能改到你所属的组。

	如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位	这句话的讲的什么意思??
	和设置组ID位都会被清除。

文件长度：
	stat结构成员st_size 表示以字节为单位的字节长度。此字段只对普通文件、目	stat结构，存在那个地方，怎么和文件进行关联??
	录文件和符号链接有意义。							stat结构中的大多数信息都取自i节点，只有两项
											数据存放在目录项中。
	对于目录，文件长度通常是一个数(例如16或512)的倍数。
	对于符号链接，文件长度是文件名中的实际字节数。				就是指向的文件的文件名的长度，不包含结尾的null。

标准I/O：
	标准I/O库，它们的操作是围绕流的，在第3章中所有I/O 函数都是针对文件描述
	符的。当用标准I/O 打开或创建一个文件时，已使一个流与一个文件相关联。可
	以对一个流调用fileno函数以获得其描述符。

FILE对象是如何定义的、每个流标志的定义以及定义为宏的各个标准I/O例程...

系统数据文件和信息：
	用户每次登录UNIX系统以及每次执行ls -l命令时都要使用口令文件。

口令文件：
	为阻止一个特定用户登录系统，除使用/dev/null之外，还有若干种替代方法。
	一种常见的方法是，将/bin/false用作登录shell。
组文件：
	/etc/group	
登录账户记录：
	大多数UNIX系统都提供两个数据文件：utmp文件，它记录当前登进系统的各个用
	户；wtmp文件，它跟踪各个登录和注销事件。

进程环境：
	当内核执行C程序时（使用一个exec函数，8.10），在调用main 前先调用一个特
	殊的启动例程。可执行程序文件将此启动例程指定为程序的其实地址，这是由连
	接编辑器设置的。启动例程从内核取得命令行参数和环境变量值。

有八种方式使进程终止(termination)，其中5种为正常终止：
	1). 从main返回
	2). 调用exit
	3). 调用_exit或_Exit
	4). 最后一个线程从启动例程返回
	5). 最后一个线程调用pthread_exit
异常终止：
	6). 调用abort
	7). 接到一个信号并终止
	8). 最后一个线程对取消请求作出响应

exit函数总是执行一个标准I/O库的清理关闭操作：为所有打开流调用fclose 函数。造成
所有缓冲的数据都被冲洗（写到文件上）。

exit,return区别


测试程序是否使用共享库：
	cc -static hello1.c	组织gcc是使用共享库

错误： 释放一个已经释放的块；调用free时所用的指针不是3个alloc函数的返回值。

如若一个进程调用malloc函数，但却忘记调用free函数，那么该进程占用的存储器就会连
续增加，这被称为泄漏(leakage)。

环境变量，更改现有的name，或者增加新的，有的需要malloc空间。

setjmp	longjmp

每个进程的都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。
进程的资源限制通常是在系统初始化时由进程0 建立的，然后由每个后续进程继承。每种
实现都可以用自己的方法对各种限制作出调整。

进程ID是唯一的，但是进程ID可以重用。当一个进程终止后，其进程ID就可以再次使用了
大多数UNIX系统实现延迟重用算法，使得赋予新建进程的ID不同于最近终止进程所使用的
ID。

ID位0的进程通常是调度进程，常常被称为交换进程（swapper）。该进程是内核的一部分
它并不执行任何磁盘上的程序，因为也被称为系统进程。

由fork创建的新进程被称为子进程（child process）。fork 函数被调用一次，但返回两
次。两次返回的唯一区别是子进程的返回值是0 ，而父进程的返回值则是新子进程的进程
ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一
个函数是一个进程可以获得其所有子进程的进程ID。fork使子进程得到返回值0 的理由是
一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID	进程ID 0总是由内核交换进程使用，所以一个子进程的
	pit_t fork(void);							进程ID不可能是0
子进程和父进程继续执行fork调用之后的指令。子进程是父进程副本。子进程获得父进程
数据空间、堆和栈的副本。这是子进程所拥有的副本。父子进程不共享这些存储存储空间
部分。父子进程共享正文段。

由于fork之后经常跟随这exec，所以现在的很多实现并不执行一个父进程数据段、堆栈的
完全复制。作为代替，使用了写时复制（copu-on-wirte，COW）技术。这些区域由父子进
程共享，而且内核将他们的访问权限改变为只读的。如果父子进程中的任一个试图修改这
些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统中的一页

Linux2.4.22提供了另外一种新进程创建函数——clone(2)系统调用。这是一种fork 的范型
它允许调用者控制哪些部分由父、子进程共享。

fork与I/O函数之间的交互关系。write函数是不带缓冲的。因为在fork 之前调用write，	缓冲区也会复制，而且行为与缓冲方式有关。
所以其数据写到标准输出一次。但是标准I/O 库是带缓冲的。如果标准输出连到终端设备
则它是行缓冲的，否则它是全缓冲的。当以交互方式运行该程序时，只得到该printf输出	8-1.c
的行一次，其原因是标准输出缓冲区由换行符冲洗。但是当标准输出定向到一个文件时，	a.out > tmp.out
却得到printf(puts)输出两次。其原因是，在fork之前调用printf一次，但当调用fork时
该行数据仍在缓冲区中，然后在将父进程数据空间复制到子进程中时，该缓冲区也被复制
到子进程中。于是那是父子进程各自有了带该行内容的标准I/O缓冲区。在exit 之前的第
二个printf将其数据添加到现有的缓冲区中。当每个进程终止时，最终会冲洗其缓冲区中
副本。

在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性
是父进程的所有打开文件描述符都被复制到子进程中。父、子进程每个相同的打开描述符
共享一个文件表项。
	父进程表项 --->			v节点表0
			文件表0 1 2	v节点表0
	子进程表项 --->			v节点表0
这种共享文件的方式使，父子进程对同一个文件使用了一个文件偏移量。

fork有下面两种用法：
* 一个父进程希望复制自己，使父子进程同时执行不同的代码段。这在网络进程中是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求到达。

* 一个进程要执行一个不同的程序。这对shell 是常见的情况。在这种情况下子进程从fork返回后立即调用exec某些操作系统把两个操作（fork之后执行exec）组合成一个，并称其为spawn。

vfork与fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程,因为子进程会立即调用exec（或exit），于是也就不会存访该地址空间。相反，在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX的页试虚拟存储器实现中提高了效率。

vfork与fork的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能调度运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁）

在8-2中，调用了_exit而不是exit。_exit并不执行标准I/O缓冲的冲洗操作。如果调用的是exit而不是_exit，则该程序的输出是不确定的。她依赖于标准I/O库的实现，可能不会有变化，也可能没有出现父进程的printf输出。				

如果exit仅仅是冲洗所有标准I/O，那么会见到输出与子进程调用_exit所产生的输出完全相同。如果该实现也关闭标准I/O流，那么表示标准输出FILE对象的相关存储去将被清0。因为子进程借用了父进程的地址空间所以当父进程恢复运行并调用printf 时，也不会产生任何输出。

exit函数-5中正常终止方式：
* 在main函数内执行return语句。等效与调用exit
* 调用exit函数。其操作包括调用各终止处理程序（由atexit 函数登记）。然后关闭所有标准I/O流等。
* 调用_exit或_Exit函数。ISOC定义_Exit，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX中，_Exit和_exit是同义的，并不清晰标准IO流。_exit函数由exit调用，它处理UNIX特定的细节。
* 当最后一个线程从启动例程返回时，改进程以终止状态0返回。该线程的返回值不会用作进程的返回值。
* 进程的最后一个线程调用pthread_exit函数。

三种异常终止方式：
	1）调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。
	2）当进程接收到某些信号时。信号可由进程自身、其他进程或内核长生。
	3）最后一个线程对“取消”（cancellation）请求作出响应。			取消---cancllation

不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打
开描述符，释放它所使用的存储器等。

退出状态 ---> 终止状态

对于父进程已经终止的所有进程，他们的父进程都改变为init进程。称这些进程由init进
程领养。操作过程：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正
要终止进程的子进程，如果是，则将该进程的父进程ID更改位1（init进程的ID ）。这种
处理方法保证了每个进程都有一个父进程。

如果子进程在父进程之前终止，内核位每个终止子进程保存了一定量的信息，所以当终止
进程的父进程调用wait、waitpid时，可以得到这些信息。在UNIX 中，一个已经终止，但	init会wait领养的进程，
是其父进程尚未对齐进行善后处理（获取终止子进程的有关信息，释放它所占用的资源）	父进程还在而且还没有wait的子进程，称为僵死进程。
的进程被称为僵死进程（zombie）。						ps -aux | grep Z -->stat Z代表僵死

当一个进程正常或异常终止时，内核就想向其父进程发送SIGCHILD信号。因为子进程终止
是个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程
发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的
函数（信号处理程序）。

wait，waitpid函数
	* 如果其所有子进程都还在运行，则阻塞。
	* 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
	* 如果它没有任何子进程，则立即出错返回。
waitpid：
	- 在一个子进程终止前，wait使其调用者阻塞，而waitpid 有一个选项，可是调用者不阻塞。
	- waitpid 并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。
	pid == -1 等待任一子进程。就这一方面而言，waitpid与wait等效。
	pid > 0   等待其进程ID与pid相等的子进程。
	pid == 0  等待其组ID等于调用进程组ID的任一子进程
	pid < -1  等待其组ID等于pid绝地值的任意子进程

如调用者阻塞而且它有多个子进程，则在其一个子进程终止时，wait就立即返回。因为wa
it返回终止子进程的进程ID，所以它总能了解是那个子进程终止了。

pit_t wait(int *statloc);
pit_t waitpid(pid_t pid, int *statloc, int options);
这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的
终止状态就存放在它指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。

对于wait ,其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返
回另一种出错。）

waitpid支持作业控制(利用WUNTRACED和WCONTINUED选项)。

int waitid(idtype_t idtype, id_tid, siginfo_t *infop, int options);
与waitpid 相似，waitid允许一个进程指定要等待的子进程。但它使用单独的参数表示要
等待的子进程的类型，而不是将此与进程ID或进程组ID组合成一个参数。

## 第十章 信号

### signal函数
Unix系统的信号机制最简单的接口是signal函数。

从UNIX系统V派生的实现支持signal函数，但该函数提供旧的$不可靠信号语义$。提供此函数主要是为了向后兼容那些需要此旧语义的应用程序，新应用程序不应使用这些不可靠信号。

Linux 2.4.22的signal语义依从BSD或者系统V，这取决于C函数库的版本，以及编译应用程序的方法。

