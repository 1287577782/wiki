首先确定一个生成项，生成项位数是m，那么数据要左移m - 1位。然后左移后的数据`除以`生成项，所得的`余`就是crc码。

在数据后面加上除数位数减1个零(或者说左移位数-1位）的原因是，能保证所有的4个数据位在除法时都能够处理到！ 不然做一次除法就得到结果了，那不对的。

除法时候的减法运算，替换成为了异或操作了，因为，减法操作有借位等操作速率慢。

除数称为生成项。

例子：数据1111，生成项1001
	1110000
	1001
	-------
	 111000
	 1001
	-------
	  11100
	  1001
	-------
	   1110
	   1001
	-------
	    110

生成项是1001，共4位比特，最高位的1，实际上在除法的每次XOR时，都要消掉，所以这个1可不做参考，后3位001才是最重要的！001有3位，所以得到的余数也是3位，因为最后一次除法XOR时，最高位消掉了。所以CRC就是3位比特的。

CRC是3比特的，表示它的宽度W=3.也就是说，原始数据后面加上W=3比特的0进行扩展!

生成项的最低位也必须是1，这是规定的。因为数据要加上的生成项位数-1个0，所以被整除的几率要大一些了。

运算时候数据项和生成项的第一位都是1，所以生成项只记录除了第高位1以外其他数据。而且在运算时候，也是先左移一位数据项，通过判断移动的这位数据项是否是1来决定是否进行xor，如果移过去的是1，那么就利用去处了最高位1的生成项与其xor。

直接计算法的实现：
{{{
#include <stdio.h>
#include <stdint.h>

uint64_t poly = 0x1;		/* POLY == 1001 */
int crc_num = 3;

uint64_t data = 0xf;		/* data:1111 */
int data_num = 4;
uint32_t regi = 0x00;		/* 3  bits */

main()
{
	uint32_t cur_bit, tmp;
	data <<= crc_num;	/* data: 111 1000 */

	/* 移动的位数一定要控制好，因为如果循环多了,而且恰好crc结果第一位是1，那么就会继续下去 */
	for (cur_bit = crc_num + data_num; cur_bit > 0; cur_bit--) {
		tmp = regi & 0x4;
		regi <<= 1;
		regi |= (data >> (cur_bit - 1)) & 0x0001;	/* 初始的几次移位，只是把原始数据移到register */
		regi &= 0x7;	/* 111 (3 bits) */
		if (tmp) {
			regi ^= poly;
		}
	}
	printf("crc --- %x\n", regi);
}
															}}}
这里使用的是生成项去除最高位的其他部分的数据，寄存器（临时操作区）一直只保持3 bit的数据，当数据最高位移到寄存器的最高位时，就tmp等于1，然后继续移出寄存器的边界了，利用后面的数据进行异或。所以这里就是利用了数据项除最高位后面的数据。

驱动表法 (Table-Driven Implementation)
{{{
首先条件是：A^B^C= A^(B^C)
例如数据项：1011 0100b;生成多项式是1 0001 1100b 
                                   1 0 1 1 1 0 0 0 
                  ________________________________
1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                   1 0 0 0 1 1 1 0 0
                   -------------------------------
                       1 1 1 0 1 0 0 0 0
                       1 0 0 0 1 1 1 0 0
                   -------------------------------
                         1 1 0 0 1 1 0 0 0
                         1 0 0 0 1 1 1 0 0
                   -------------------------------
                           1 0 0 0 0 1 0 0 0
                           1 0 0 0 1 1 1 0 0
                   -------------------------------
                                   1 0 1 0 0 0 0 0
上面式子可以写成这样：
				   1 0 1 1 1 0 0 0 
                  ________________________________
1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                   1 0 0 0 1 1 1 0 0              --->
                     0 0 0 0 0 0 0 0 0            --->
                       1 0 0 0 1 1 1 0 0          --->
                         1 0 0 0 1 1 1 0 0        --->
                   -------------------------------
                           1 0 0 0 0 1 0 0 0
                           1 0 0 0 1 1 1 0 0
                   -------------------------------
                                   1 0 1 0 0 0 0 0
驱动表法是用空间换时间，高四位是1011，那么这个我们四次生成多项式的移位计算给计算出来(是生成项长度减一)，使用前面高四位作为索引，建立一张表。后面的值，直接和生成项的计算结果进行异或，如下:
				     1 0 1 1 1 0 0 0 
                  ________________________________
1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                  (1 0 1 1)1 1 0 0 0 1 0 0
                   -------------------------------
                           1 0 0 0 0 1 0 0 0
                           1 0 0 0 1 1 1 0 0
                   -------------------------------
                                   1 0 1 0 0 0 0 0
驱动表生成函数：
#include <stdio.h>
#define LUT_WIDTH	4
#define CRC_WIDTH	8
#define CRC_POLY	0x11c 	/* 1 0001 1100 */
fun()
{
	int table[1 << LUT_WIDTH];
	int index = 0, tmp, bit_cnt;
	for (index; index < (1 << LUT_WIDTH); index++) {		/* 0 ---> 1111 */
		tmp = 0;
		for (bit_cnt = LUT_WIDTH; bit_cnt > 0; bit_cnt--) {	/* 依次检查4位的值，进行移位异或 */
			if ((index >> (bit_cnt - 1)) & 0x1 == 1)
				tmp ^= (CRC_POLY << (bit_cnt -1)) & 0xff;
		}
		table[index] = (unsigned char) tmp;

	}

	printf("%d --- %x\n", 11, table[11]);				/* 1011 --- 1100 0100 */
}
/* 1110 0
 * 0000 00
 * 0011 100
 * 0001 1100
 * ----------
 * 1100 0100	---> 0xc4
 */
main()
{
	fun();
}
															}}}
一般是用一个字节作为表索引的，那么原数据的长度是有要求的。否则会部分使用驱动表法，部分计算，如果数据过短可能会直接使用直接计算法了。

直驱表法：
