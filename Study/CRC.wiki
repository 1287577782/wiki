首先确定一个生成项，生成项位数是m，那么数据要左移m - 1位。然后左移后的数据`除以`生成项，所得的`余`就是crc码。

在数据后面加上除数位数减1个零(或者说左移位数-1位）的原因是，能保证所有的4个数据位在除法时都能够处理到！ 不然做一次除法就得到结果了，那不对的。

除法时候的减法运算，替换成为了异或操作了，因为，减法操作有借位等操作速率慢。

除数称为生成项。

例子：数据1111，生成项1001
	1110000
	1001
	-------
	 111000
	 1001
	-------
	  11100
	  1001
	-------
	   1110
	   1001
	-------
	    110

生成项是1001，共4位比特，最高位的1，实际上在除法的每次XOR时，都要消掉，所以这个1可不做参考，后3位001才是最重要的！001有3位，所以得到的余数也是3位，因为最后一次除法XOR时，最高位消掉了。所以CRC就是3位比特的。

CRC是3比特的，表示它的宽度W=3.也就是说，原始数据后面加上W=3比特的0进行扩展!

生成项的最低位也必须是1，这是规定的。因为数据要加上的生成项位数-1个0，所以被整除的几率要大一些了。

运算时候数据项和生成项的第一位都是1，所以生成项只记录除了第高位1以外其他数据。而且在运算时候，也是先左移一位数据项，通过判断移动的这位数据项是否是1来决定是否进行xor，如果移过去的是1，那么就利用去处了最高位1的生成项与其xor。

直接计算法的实现：
```
    #include <stdio.h>
    #include <stdint.h>
    
    uint64_t poly = 0x1;		/* POLY == 1001 */
    int crc_num = 3;
    
    uint64_t data = 0xf;		/* data:1111 */
    int data_num = 4;
    uint32_t regi = 0x00;		/* 3  bits */
    
    main()
    {
    	uint32_t cur_bit, tmp;
    	data <<= crc_num;	/* data: 111 1000 */
    
    	/* 移动的位数一定要控制好，因为如果循环多了,而且恰好crc结果第一位是1，那么就会继续下去 */
    	for (cur_bit = crc_num + data_num; cur_bit > 0; cur_bit--) {
    		tmp = regi & 0x4;
    		regi <<= 1;
    		regi |= (data >> (cur_bit - 1)) & 0x0001;	/* 初始的几次移位，只是把原始数据移到register */
    		regi &= 0x7;	/* 111 (3 bits) */
    		if (tmp) {
    			regi ^= poly;
    		}
    	}
    	printf("crc --- %x\n", regi);
    }
```
这里使用的是生成项去除最高位的其他部分的数据，寄存器（临时操作区）一直只保持3 bit的数据，当数据最高位移到寄存器的最高位时，就tmp等于1，然后继续移出寄存器的边界了，利用后面的数据进行异或。所以这里就是利用了数据项除最高位后面的数据。

驱动表法 (Table-Driven Implementation)
```
    首先条件是：A^B^C= A^(B^C)
    例如数据项：1011 0100b;生成多项式是1 0001 1100b
                                       1 0 1 1 1 0 0 0 
                      ________________________________
    1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                       1 0 0 0 1 1 1 0 0
                       -------------------------------
                           1 1 1 0 1 0 0 0 0
                           1 0 0 0 1 1 1 0 0
                       -------------------------------
                             1 1 0 0 1 1 0 0 0
                             1 0 0 0 1 1 1 0 0
                       -------------------------------
                               1 0 0 0 0 1 0 0 0
                               1 0 0 0 1 1 1 0 0
                       -------------------------------
                                       1 0 1 0 0 0 0 0
    上面式子可以写成这样：
    				   1 0 1 1 1 0 0 0 
                      ________________________________
    1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                       1 0 0 0 1 1 1 0 0              --->
                         0 0 0 0 0 0 0 0 0            --->
                           1 0 0 0 1 1 1 0 0          --->
                             1 0 0 0 1 1 1 0 0        --->
                       -------------------------------
                               1 0 0 0 0 1 0 0 0
                               1 0 0 0 1 1 1 0 0
                       -------------------------------
                                       1 0 1 0 0 0 0 0
    驱动表法是用空间换时间，高四位是1011，那么这个我们四次生成多项式的移位计算给计算出来(是生成项长度减一)，使用前面高四位作为索引，建立一张表。后面的值，直接和生成项的计算结果进行异或，如下:
    				     1 0 1 1 1 0 0 0 
                      ________________________________
    1 0 0 0 1 1 1 0 0/ 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0
                      (1 0 1 1)1 1 0 0 0 1 0 0
                       -------------------------------
                               1 0 0 0 0 1 0 0 0
                               1 0 0 0 1 1 1 0 0
                       -------------------------------
                                       1 0 1 0 0 0 0 0
    驱动表生成函数：
    #include <stdio.h>
    #define LUT_WIDTH	4
    #define CRC_WIDTH	8
    #define CRC_POLY	0x11c 	/* 1 0001 1100 */
    fun()
    {
    	int table[1 << LUT_WIDTH];
    	int index = 0, tmp, bit_cnt;
    	for (index; index < (1 << LUT_WIDTH); index++) {		/* 0 ---> 1111 */
    		tmp = 0;
    		for (bit_cnt = LUT_WIDTH; bit_cnt > 0; bit_cnt--) {	/* 依次检查4位的值，进行移位异或 */
    			if ((index >> (bit_cnt - 1)) & 0x1 == 1)
    				tmp ^= (CRC_POLY << (bit_cnt -1)) & 0xff;
    		}
    		table[index] = (unsigned char) tmp;
    
    	}
    
    	printf("%d --- %x\n", 11, table[11]);				/* 1011 --- 1100 0100 */
    }
    /* 1110 0
     * 0000 00
     * 0011 100
     * 0001 1100
     * ----------
     * 1100 0100	---> 0xc4
     */
    main()
    {
    	fun();
    }
    
    计算0x31, 0x32, 0x33, 0x34对CRC-CCITT（CRC16，POLY=0x1021）的计算。高亮的字体就是每一步的寄存器中的数据。
            __________________
      10 21/ 31 32 33 34 00 00
                26 72           --> index=31
            ------------------
                14 41 34 00 00
                   52 B5        --> index=14
            ------------------
                   13 81 00 00
                      22 52     --> index=13
            ------------------
                      A3 52 00
                         85 89  --> index=A3
            ------------------
                         D7 89
    															
```
直驱表法：
下面是驱动表法(index-8, crc16)的计算列式，后面是对index和data的关系总结。见driven-direct-tab.c
直驱表法就是驱动表法的列式对于数据项的总结,然后得出对于数据项的依次处理关系。
```
    31 32 33 34 00 00   --> data(1)=31, data(2)=32, data(3)=33, data(4)=34
    	26 72           --> index(1)=31, 31 = data(1) ^ 00
    ------------------
    	14 41 34 00 00
    	   52 B5        --> index(2)=14, 14 = data(2) ^ table(index(1))[15:8] 
    ------------------
    	   13 81 00 00
    	      22 52	    --> index(3)=13, 13 = data(3) ^ table(index(2))[15:8] ^ table(index(1))[7:0]
    ------------------
    	      A3 52 00
    		 85 89  --> index(4)=A3, A3 = data(4) ^ table(index(3))[15:8] ^ table(index(2))[7:0]
            ------------------
    		 D7 89
    index(n) = data(n)[7:0] ^ table(index(n-1))[15:8] ^ table(index(n-2))[7:0];
    result = index(last);
    
    for(i=0; i<len; i++){                                                           
        print_regs(CRC_WIDTH, regs);                                                
        regs = (regs<<BYTE_L) ^ table[(regs>>(CRC_WIDTH-BYTE_L)) & 0xFF ^ *pointer++];
    }                                                                               
    就是数据项与原来的regs中的第一个字节异或的值所谓索引的表值，然后regs左移一个字节再和前面的表值异或。
    31 --> 00 00
           31 26 72
          ------------------
    32 -----> 26 72
              14 52 B5
          ------------------
    33 --------> 20 B5
                 13 22 52
          ------------------
    34 -----------> 97 52
                    A3 85 89
          ------------------
                       D7 89
    regs[15:8]=0x00, index=0x31 result --> 0x2672h
    regs[15:8]=0x72, index=0x14 result --> 0x20B5h
    regs[15:8]=0xB5, index=0x13 result --> 0x9752h
    regs[15:8]=0x52, index=0xA3 result --> 0xD789h
    result --> 0xD789h
```
