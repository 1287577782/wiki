Handoff 切换
CDMA术语
从一个基站向另一个基站转移用户站通信之动作。硬切换的特点是，通信信道短暂中断。
软切换的特点是，一个以上的基站同时与同一个用户站保持通信。
Handoff: transfer a call or data session from one channel to another, or from 
one BS to another, or from one MSC to another.
Handover: the process of transferring a call
Hard handover: the process needs to drop the call for a short time, e.g., 
GSM handover
Soft handover: MS simultaneously use multiple BS, no need to drop the call
when adding new BS, e.g., CDMA system
Handoff 又称为 Handover (HO) 是所有蜂窝通信系统共有的特征。根据切换类型可以分为，
硬切换，软切换，更软切换等。 硬切换用于GSM网络，软切换是CDMA 网络的特征之一。

PCF --- PDSN
	PCF(packet control function)一般与BSC在一起。PCF的功能主要是
在BSC和PDSN提供PPP帧的传输，它是RLP(无线链路协议)连接的终止点。
	PDSN是CDMA分组网中的核心设备，是一种无线接入网(RAN)和分组交
换公共数据网(Packet Switch Public Data NetWork, PSPDN)之间的网关。
简言之，是CDMA2000网络中移动终端访问互联网的接入设备。PDSN是PPP连接
的终止点，提供IP数据包的路由。

2.R-P链路请求 ->
3.R-P链路响应 <-
8.动态分配IP地址

业务信道的分配，A10连接的建立，链路层(PPP)的建立，移动IP注册。
执行完以上操作之后，用户数据业务就可以封装在GRE帧中在A10连接中传送了。
在A10连接的生存期超时前，PCF通过向所选的PDSN发送注册请求消息来定期的进行重注册。



PCF切换：
	移动终端应保持相同的PPP连接和同样的IP地址。
PDSN切换：
	当用户发生PDSN间切换后，由于需要重新建立PPP连接，重新获取IP
	地址。

CDMA2000数据：
		IP
		PPP	
	GRE	GRE
	IP	IP
	Link	Link
	Phys	Phys
GRE:
	控制报文:UDP 699,PPP IPCP/LCP
	数据报文：CDMA2000 A10标准

PDSN仿真Home Agent(HA),PCF仿真手机节点。

首先:当注册时候PCF用以个虚假的Home Address(=0.0.0.0). PDSN也回复0.0.0.0这个地址。	A.	13
	PDSN使用会话指定扩展(IMSI 和SR_ID)作为手机节点的标识。
第二:
第三:
	Registration Request and Registration Reply 不仅仅用于注册，也被用来在PCF和PDSN之间交换信息

A10的释放是由PCF控制的。PDSN初始化A10连接的释放，PDSN请求PCF释放连接。

A11注册请求是由PCF向PDSN发起的，用于初始化建立，更新和释放一个A10连接。
除此之外，与一个A10连接有关的账户信息可能被包含在任何一个和这个A10连接有关的A11注册请求.

/*	 PCF --- PDSN 	*/
PCF通过向被选中的PDSN发送一个有生存时间的A11注册请求初始化一个A10连接设置。在发送完这个消息之后，
PCF将会启动定时器T(regreq)。请求消息结构在3.1部分。
如果连接设置请求被接受PDSN则通过创建PDSN SID和IMSI MNSRID PCF-Addr的联系来为A10连接创建一个绑定记录。
如果PCF，PDSN都支持高于0的会话标识版本，则PDSN可以选择任意的PDSN SID，否则PDSN SID将会和PCF SID一致
在有多个A10连接同一个MS的情况下，每个A10连接拥有它自己的绑定记录和生存时间定时器。
PCF和PDSN将会使用PCF IP Addr(在A11注册请求),和PDSN IP Addr(在A11注册响应中),作为A10用户传输连接通信
的端地址.The PCF IP Address and the PDSN IP Address form the unique link layer ID for each A10 
connection. The PCF and the PDSN maintain an association of the MS’s IMSI address and MN Session
Reference ID with the A10 connection.
当创建一个新的A10连接，PCF将会包含ANID NVSF和在13中指定的CANID。如果PCF接收到来自于BS的ANID,PCF将会
把ANID放在A11注册请求消息的PANID里面。
所有含有一个非空生存时间的A11注册请求发向一个已经存在的A10连接，都是对这个A10连接的刷新请求。当一个
A11-注册请求消息向一个存在的A10连接，PCF将会使用同样的key值。

A11-extensions are defined in the TLV format.Length field indicates the length (in octets) of the
extension, not including the Type and Length fields.

flag_insp_3g_cdma

test:
发同样的包的不同情况，replay1800,ipcp(pcf - pdsn),ipcp(pdsn - pcf), replay0
PP0:~CONSOLE-> 1460036060066514		r-1800				0
PP2:~CONSOLE-> 1460036060066514		r-0				 	2
PP1:~CONSOLE-> user_ip = aea693c	ipcp(pcf-pdsn)			    1
PP0:~CONSOLE-> pdsn lock ----- ok	r-1800 add pdsn			0
PP1:~CONSOLE-> user_ip = a71c2e8	ipcp(pdsn-pcf)			    1
PP0:~CONSOLE-> add pdsn ok		r-1800 add pdsn ok		0
PP1:~CONSOLE-> del time ok		ipcp(pdsn-pcf) add user		    1
PP1:~CONSOLE-> add node ok		ipcp(pdsn-pcf) add user ok	    1
PP2:~CONSOLE-> pdsn lock ----- ok	r-0 del user					2
PP2:~CONSOLE-> del user set 0 ok	r-0 del user ok					2
PP1:~CONSOLE-> user_timeout lock ok	r-0 set time to out		    1

PP0:~CONSOLE-> 1460036060066514
PP2:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> pdsn lock ----- ok
PP1:~CONSOLE-> user_ip = aea693c
PP0:~CONSOLE-> add pdsn ok
PP1:~CONSOLE-> user_ip = a71c2e8
PP2:~CONSOLE-> pdsn lock ----- ok
PP2:~CONSOLE-> same pdsn
PP1:~CONSOLE-> del time ok
PP1:~CONSOLE-> add node ok

tcpreplay -l 0
PP0:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP0:~CONSOLE-> pdsn lock ----- ok
PP1:~CONSOLE-> user_ip = a71c2e8
PP2:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> add pdsn ok
PP2:~CONSOLE-> pdsn lock ----- ok
PP2:~CONSOLE-> same pdsn
PP1:~CONSOLE-> del time ok
PP1:~CONSOLE-> add node ok

PP0:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP2:~CONSOLE-> user_ip = a71c2e8
PP0:~CONSOLE-> pdsn lock ----- ok
PP3:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> update time ok
PP2:~CONSOLE-> the same node ---
PP3:~CONSOLE-> pdsn lock ----- ok
PP3:~CONSOLE-> del user set 0 ok

PP0:~CONSOLE-> 1460036060066514
PP3:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP2:~CONSOLE-> user_ip = a71c2e8
PP0:~CONSOLE-> pdsn lock ----- ok
PP1:~CONSOLE-> 1460036060066514
PP4:~CONSOLE-> user_ip = a71c2e8
PP6:~CONSOLE-> 1460036060066514
PP5:~CONSOLE-> user_ip = aea693c
PP5:~CONSOLE-> 1460036060066514
PP7:~CONSOLE-> user_ip = aea693c
PP9:~CONSOLE-> 1460036060066514
PP8:~CONSOLE-> user_ip = a71c2e8
PP7:~CONSOLE-> 1460036060066514
PP10:~CONSOLE-> user_ip = aea693c
PP11:~CONSOLE-> user_ip = a71c2e8
PP10:~CONSOLE-> 1460036060066514

1:
PP0:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP2:~CONSOLE-> user_ip = a71c2e8
PP0:~CONSOLE-> pdsn lock ----- ok
PP3:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> add pdsn ok
PP3:~CONSOLE-> pdsn lock ----- ok
PP3:~CONSOLE-> same pdsn
PP2:~CONSOLE-> del time ok
PP2:~CONSOLE-> add node ok
2:
PP0:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP2:~CONSOLE-> user_ip = a71c2e8
PP3:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> pdsn lock ----- ok
PP0:~CONSOLE-> update time ok
PP2:~CONSOLE-> the same node ---
PP3:~CONSOLE-> pdsn lock ----- ok
PP3:~CONSOLE-> del user set 0 ok
3:
PP0:~CONSOLE-> 1460036060066514
PP1:~CONSOLE-> user_ip = aea693c
PP2:~CONSOLE-> user_ip = a71c2e8
PP3:~CONSOLE-> 1460036060066514
PP0:~CONSOLE-> pdsn lock ----- ok	 /* add_user_in_pdsn while 没加l = l->next,加入节点后一直在第一个节点转，死循环。 

PP4:~CONSOLE-> 1460036060066514
PP7:~CONSOLE-> user_ip = a71c2e8
PP6:~CONSOLE-> 1460036060066514
PP5:~CONSOLE-> user_ip = aea693c

PP5:~CONSOLE-> 1460036060066514
PP8:~CONSOLE-> user_ip = aea693c
PP9:~CONSOLE-> 1460036060066514
PP8:~CONSOLE-> user_ip = a71c2e8


PP10:~CONSOLE-> 1460036060066514
PP11:~CONSOLE-> user_ip = aea693c
PP11:~CONSOLE-> user_ip = a71c2e8

nothing...
---

epim decode:
------------------                                                
ep herer is                                                       
begin to decode gre user_ip                                       
45 00 00 3e 00 08 00 00 fffd 2f ffed 3f ffac 1c 78 05 ffac 1c 00 0b 30 00 ff88 ff81 00 00 00 02 00 00 
30 00 ff88 ff81 00 00 00 02 00 00 00 07 7e ffff 03 ff80 21 02 02 00 16 03 06 0a 71 ffc2 ffe8 ff81 06 73 
-----
for (i = 0; i < 30; i++)
{
        printf("%02hhx ", *((char *)gre + i));
        
}       
printf("\n");


PP0:~CONSOLE-> ep herer is 
PP0:~CONSOLE-> begin to decode gre user_ip
PP0:~CONSOLE-> 45 00 00 3e 00 08 00 00 fffd 2f ffed 3f ffac 1c 78 05 ffac 1c 00 0b 30 00 ff88 ff81 00 00 00 02 00 00 
PP0:~CONSOLE-> gre.ver =0
PP0:~CONSOLE-> gre.type =8881
PP0:~CONSOLE-> 30 00 ff88 ff81 00 00 00 02 00 00 00 07 7e ffff 03 ff80 21 02 02 00 16 03 06 0a 71 ffc2 ffe8 ff81 06 73 

多次声明的bug：
-------------------
if(cvmx_likely(pgsreg->ctrl_sw.flag_insp_3g_cdma))               
{
        cdma_user_t *u = get_user_by_triple_cdma(dpp->pkthdr.sip,
                                                 dpp->pkthdr.dip,
                                                 dpp->gre_key);  
        if (!u) {
		cdma_user_t *u = get_user_by_triple_cdma(dpp->pkthdr.dip,	//如果这里还声明，u就会是NULL不管，返回的什么。
                                        dpp->pkthdr.sip,         		//就是if里面局部的，变量了。 靠
                                        dpp->gre_key);           
        }                                                        
        if(cvmx_likely(u)){
                set_cdma_user_to_pkt(dpp, u);                    
                cdma_user_put(u);                                
        }
}       

if(cvmx_likely(pgsreg->ctrl_sw.flag_insp_3g_cdma))               
{
        cdma_user_t *u = get_user_by_triple_cdma(dpp->pkthdr.sip,
                                                 dpp->pkthdr.dip,
                                                 dpp->gre_key);  
        if (!u) {
                u = get_user_by_triple_cdma(dpp->pkthdr.dip,
                                        dpp->pkthdr.sip,         
                                        dpp->gre_key);           
        }                                                        
        if(cvmx_likely(u)){
                set_cdma_user_to_pkt(dpp, u);                    
                cdma_user_put(u);                                
        }
}       

