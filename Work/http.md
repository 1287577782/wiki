# 超文本传输协议-http

> 一个tcp报文中可以包含多个http数据报

## 总体操作
### http协议是一种请求/响应型的协议
客户端给服务器发送请求的格式是一个请求方法（request method），URL，协议版本号，然后紧接着一个包含请求（modifiers），客户端信息，和可能的消息主题的类MIME（MIME-like）消息。

服务器对请求端发送响应的格式是以一个状态行（status line），其后跟随一个包含服务器信息、实体元信息和可能的实体主体内容的类MIME（MIME-like）的消息。其中状态行（status line）包含消息的协议版本号和一个成功或错误码。

> MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开，多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。

## BNF 巴克斯-诺尔范式
### name=definition
name就是代表规则的名字，规则名不能包含"<"、">"，通过等号把规则名和规则定义分开。空格只有在采用延续行缩进来指定跨度多于一行的规则定义的时候才有意义。

### 字面文本(literal)
字面文本两边用引号。除非声明，字面文本大小写不敏感（如,HEY="A"|"B"|"a"|"b")

### 规则1|规则2
由竖线（“|”）分开的元素是可选的，例如,"yes"|"no"表示yes或no都是可接受的。

### (规则1|规则2)
围在括号里的多个元素视作一个元素。所以，"(elem (foo|bar) elem)"符合的字符串是："elem foo elem"和"elem bar elem"。

### *规则
前面的字符"*"表示重复。

完整形式是"<n>*<m>"，表示至少出现<n>次，至多出现<m>次。默认值分别是0和无穷大。

### [规则]
$方括号里是任选元素："[foo bar]"相当于"*1 (foo bar)"$

### N规则
特殊的重复："<n> (元素)"与"<n>*<n> (元素)"等价;就是说，(元素)正好出现<n>次。

### #规则
$类似于"*"，结构"#"是用来定义一系列元素的。完整的形式<n>#<m>元素，表示至少<n>个元素，至多<m>个元素，元素之间被一个或多个都好(",")以及可选的线性空白(LWS)隔开了。$

### 注释（comment）
用分号引导注释。

## HTTP消息
### 消息类型
HTTP消息由从客户到服务器的请求消息和从服务器到客户的响应消息两部分组成。

### 消息的组成
两中类型的消息组成
* 一个开始行（start-line）

* 0个或更多个头域（经常被称作“头”）

* 一个指示头域结束的空行（也就是一个以CRLF为前缀的什么也没有的行）

* 最后一个可有可无的消息主体（message-body）组成

> 为了健壮性，服务器应该忽略任意请求行（Request-Line）前面的空行。

### 消息头(Message Headers)
HTTP头域包括常用头域，请求头域，响应头域和实体头域。

每个头域有一个名字（域名）跟随一个":"和域值构成。域名是大小写不敏感的。域值前面可能有任意数量的LWS,但SP（空格）是首选的。

> LWS: 线性空白

头域能被延伸多行，这通过在这些行面前加一些SP或HT。应用程序当产生HTTP消息时，应该遵循"常用格式"，因为可能存在一些应用程序，他们不能接收任何常用形式之外的形式。

不同域名的头域被接收的顺序是不重要的。然而，首先发送常用头域，然后紧接着是请求头域或者响应头域，然后是以实体头域结束。

### 消息主体(Message Body)
HTTP消息的 _消息主体_ 用来承载请求和响应的 _实体主体_ （entity-body）。

消息主体（message-body）仅仅当被传输译码头域（Transfer-Encoding）指明的传输编码（transfer-coding）应用于实体主体（entity-body）时才和实体主体相区别，其它情况消息主体和实体主体相同。

传输译码头域被用指明应用程序的传输编码，它是为了保证消息的安全和合适的传输。传输译码（Transfer-Encoding）头域是消息的属性，而不是实体的属性，因此可能会沿着请求/响应链被添加或删除。

请求中消息主体的存在是被请求中消息头域中是否存在内容长度（Content—Length)或传输译码（Transfer-Encoding）头域来通知的。

* 如果某种请求方法不支持请求里包含实体主体，那么一个消息主体（message-body）不能被包含。

对于响应消息，消息里是否包含消息主体依赖相应的请求方法和响应状态码。

* 所有HEAD请求方法的请求的响应消息不能包含消息主体，即使实体头域出现在请求里。

* 所有1XX（信息的），204（无内容的）和304（没有修改的）的响应都不能包含一个消息主体。

* 所有其他的响应必须包含消息主体，即使它长度可能为0.

### 消息的长度
当消息主体出现在消息中时，一条消息的传输长度是消息主体的长度；也就说在实体主体被应用了传输编码后。当消息中出现消息主体时，消息主体的传输长度有下面（以优先权顺序）决定：

1. 任何不能包含消息主体的消息总被头域后的第一个空行（CRLF）终止，不管消息里是否存在实体头域。

2. 如果...

### 常用头域
有一些头域即适用于请求消息也适用于响应消息，但是这些头域不适合传输实体。这些头域只能应用于传输消息。

不被识别的头域会被作为实体头域来看待。

## 请求
一个请求消息是从客户端到服务器端的，在消息首行里包含方法，资源指示符，协议版本。

### 请求行
请求行（Request-Line）是以一个 _方法标记_ 开始，后面跟随Request-URI和协议版本（HTTP-Version），最后以CRLF结束。元素是以SP字符分隔。除了最后的CRLF，CR或LF是不被允许的。

#### 方法-Method
方法标记（token）指明了在被Reuest-URI指定的资源上执行的方法。这种方法是大小写敏感的。
```
    Method = "OPTIONS"|"GET"|"POST"|"PUT"|"DELETE"|"TRACE"|"CONNECT"|extension-method
```
资源所允许的方法有Allow头域指定。响应的返回码总是通知客户某个方法对当前资源是否是被允许的，因为被允许的方法能被动态的改变。如果服务器能理解某方法但此方法对请求资源不被允许，那么源服务器应该返回405状态码（方法不允许）；如果源服务器不能识别或没有实现某个方法，那么服务器应返回501状态码（没有实现）。方法GET和HEAD必须被所有一般的服务器支持。所有其他的方法是可选的。

#### 请求URL（Request-URL）
Request-URL是一种通用资源标识符，并且它用于指定请求的请求资源。
```
    Request-URI = "*"|absoluteURI|abs_path|authotity
```
"*"
```
    OPTIONS * HTTP/1.1
```

* 绝对URI
```
    GET http://www.w3.org/pub/www/TheProject.html HTTP/1.1
```

* 绝对路径（absolute path）不能是空的；如果在原始URI里没有出现绝对路径，必须给出“/”（服务器的根）。
```
    GET /pub/WWW/TheProject.html HTTP/1.1
    Host: www.w3.org
```
authority格式只被用于CONNECT方法。

相对路径应该是页面的其他资源相对于整个url。

### 请求资源的识别（The Resource Identified by a Request）
* 如果Request-URI是绝对地址（absoluteURI），那么主机（host）是Request—URI的一部分。任何出现在请求里Host头域的值应当被忽略。

* 如果Request-URI不是绝对地址，并且请求包括一个Host头域，则主机（host）由该Host头域的值决定。
 
### 请求头域（Request Header Fields）
请求头域允许客户端传递请求的附加信息和客户端自己的附加信息给服务器。这些头域作为请求的修饰，这和程序语言方法调用的 _参数_ 语义是等价的。

## 响应
接收和解析一个请求消息后，服务器发出一个HTTP响应消息。
响应的巴诺范式：
```
respone = Status-Line
		*((general-header)
						|response-header
						|entity-header)CRLF
						CRLF
						[message-body]
```

### 状态行
响应消息的第一行是状态行，有协议版本以及数字状态码和相关的文本短语组成，各部分间用空格符隔开，除了最后的CRLF序列，中间不允许有CR或LF。

Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF

### 响应头域
响应头域允许服务器传送响应的附加信息，这些信息不能放在状态行里。这些头域给出有关服务器的信息以及请求URI指定资源的更进一步访问信息。

## 实体
如果不被请求方法或响应状态码所限制，请求和响应都可以传输实体。实体包括 _实体头域_ 与 _实体主体_ ，而有些响应只包括实体头域。

> 这里更一步区分出了消息主体和实体主体。

### 实体主体
由HTTP请求或响应发送的实体主体的格式与编码方式应由实体的头域决定。

实体主体只有当消息主体存在时才存在。实体主体从消息主体根据传输译码头域解码得到，传输译码用于确保消息的安全和合适传输。

### 类型
当消息包含实体主体时，主体的数据类型由实体头域的Content-Type和Content—Encoding头域确定。

### 压缩---内容编码
* HTTP定义了一些标准的内容编码类型，并允许用扩展的形式添加更多的编码。

* Content-Encoding header 就用这些标准化的代号来说明编码时使用的算法

* Content-Encoding值

* gzip　　表明实体采用GNU zip编码

* compress 表明实体采用Unix的文件压缩程序

* deflate　　表明实体是用zlib的格式压缩的

* identity　　表明没有对实体进行编码。当没有Content-Encoding header时， 就默认为这种情况

> gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。 其中gzip通常效率最高， 使用最为广泛。

