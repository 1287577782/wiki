MIPS五级流水线：
	IF(instruction fetch) 取指，从指令高速缓存(I-cache)获取下一条指令。

	RD(read register) 读寄存器，读取该指令的源寄存器域指定的CPU寄存器的内容。

	ALU(arithmetic/logic unit) 在一个时钟周期内完成算术或者逻辑操作(浮点运算
	和整数乘除无法在一个时钟周期内完成，对其处理有所不同)

	MEM(mem) 访问内存该阶段指令可以读写数据高速缓存(D-cache)中的内存变量，平
	均而言，每四条指令中就有三条指令在该阶段没有任何操作，但是每条指令都分配
	了这一阶段以确保不会出现两条指令同时需要访问数据高速缓存的情形。

	WB(write back)写回寄存器,将操作结果值写道寄存器中.

	MIPS所有的指令长度都是32位，MIPS的二进制文件比典型的80*86大百分之二十到三
	十。但是不可能把一个32位常数放进单个指令中。MIPS留出26位常数的空间用以编
	码跳转和调用指令的目标地址，这样的指令只有两条。其他指令只能有16位空间留
	给常数。这样装入任意32位数值需要一个两条指令的序列，条件分支被限制到64K		指令序列；代码段取指，条件分支
	指令范围。

	三操作数的指令：
	算术/逻辑指令都不需要指定内存地址，所以空出了充足的指令位可以定义两个独立
	的源操作数和一个目的操作数。

	没有条件码：
	MIPS的指令集的一个特征就是没有条件标志，许多体系结构有多个标志位来表示运算
	结果的“进位”，“为零”等等。CISC的典型做法是根据一些指令的操作结果设置这些标
	志，有些RISC体系结构保留了标志位。
	MIPS体系结构把所有信息保存到寄存器堆中。比较指令设置通用寄存器，条件分支指
	令检测通用寄存器。
	这里有效的条件分支意味着是否分支的决定必须在半个流水线周期内作出；该体系结
	构通过保持分支决策的测试条件简单有助于实现这一点。所以MIPS的条件分支只测试
	单个寄存器的符号/为零或者一对寄存器是否相等。

	指令在内存中都是四字节边界对齐的:
	MIPS指令的最小操作码域为6位，留出了26位来定义跳转的目标，因为所有指令在内
	存中都是四字节边界对齐的，低两位无需保存，这样可有2^28=256MB的地址范围(段	指令是四字节对齐，那么数据呢？
	内绝对地址)。
	条件分支只有16位的偏移域---给出了2^18字节的范围，因为指令都是四字节对齐的。
	四字节对齐 ： 内存中是四字节对齐是说只需要指向四字节的第一个地址就OK了，

寻址和访存:
	访问内存只能通过简单的寄存器加载和存储:每次内存访问都要一条显式的加载或存
	储指令。

	只有一种数据寻址方式:几乎所有的加载和存储都通过单个寄存器基址加上一个16位
	的常数偏移量寻址内存。

	字节地址指令:一旦数据存入MIPS CPU的寄存器，所有的操作都是在整个寄存器上操
	作。但是像C这样的语言语义不适合不能寻址内存到字节粒度的机器。因而MIPS对8-
	和16-位变量(分别称为字节和办字)提供了一套完整的装入/存储操作.一旦数据到达
	寄存器，就当作寄存器全长来处理.所以部分字加载指令有两种形式——符号扩展和零
	扩展。

	load/store必须对齐:内存操作只能对齐到相应数据类型边界的地址加载和存储数据。
	字节可以在任意地址传输，但是半字必须在偶数地址对齐，字在四字节边界对齐。
	许多CISC微处理器可以从任意字节地址加载/存储四字节数据，但是要花费额外的时
	钟周期。

	跳转指令:有限的32位指令长度想要支持很大程序的体系结构上对分支是个问题。MI
	PS指令的最小操作码域为6位，留出了26位来定义跳转的目标。因为所有指令在内存
	中都是四字节对齐边界的，低两位地址无需保存，这样有2^28=256MB的地址范围。
	这个地址不是相对PC的，而是解释成256MB段内的绝对地址。这对于大于256MB的单个
	程序极为不便。
	超出段内的分支可以通过使用一个寄存器跳转指令做到，该指令可以跳到任意32位地
	址。
	条件分支只有16位的偏移域——给出了2^18字节的范围，因为指令都是四字节对齐的--
	解释成相对PC的带符号的偏移量。如果知道分支目标会在紧跟分支之后的指令的128K
	B范围内，编译器就能只生成一个简单的条件分支指令。


MIPS没有的特性：
	没有字节或半字数据的运算：所有算术和逻辑操作都是在32位的数据上进行。字节或
	半字的运算需要大量额外的资源和许多额外的操作码，而且很少有用。C语言的语法
	让大多数的计算用int类型，对MIPS而言int就是32位的整数。然而当程序明确做sh-
	ort或者char运算时，MIPS编译器必须插入额外的代码以保证结果回绕和溢出，生成	是不是声明使用半字，字节会影响速度？
	跟16-或8-位机器上一样的结果。

	没有对堆栈的特殊支持：传统MIPS汇编确实定义一个寄存器作为堆栈指针，但是硬
	件上SP没有任何特殊之处。有一种推荐的关于子程序调用的栈帧布局，这样可以混
	合不同语言和编译器的模块；你应当遵守这些约定，但是这些与硬件无关。堆栈弹
	出不能适应流水线，因为有两个寄存器要写（来自堆栈的数据和增加指针值）。

	最少的子程序支持：有一点比较特别，跳转指令有一个跳转并连接的选项，把返回
	地址存入一个寄存器，默认是$31.所以习惯上用31作为返回地址寄存器.这样做比
	起把返回地址保存到堆栈上要简单，但却带来明显的好处。第一保持了分支和访存
	指令的完全分离；第二，当调用许多根本不需要在堆栈保存返回地址的小程序时，
	这样有助于提高效率。

	最少的中断处理：
	最少的异常处理：
流水：
	数据加载延迟 	:加载延迟槽。

	延迟分支	:分支延迟槽。
	分支延迟槽 (Branch delay slot)，简单地说就是位于分支指令后面的一条指令，
	不管分支发生与否其总是被执行，而且位于分支延迟槽中的指令先于分支指令提交
	(commit)。
	如：
	jal printf
	move $4,$6
	xxx #move指令总是被执行的。
	分支延迟槽在 DSP 和历史较悠久的 RISC 上比较常见，如 MIPS,  SPARC 等。Po-
	werPC 和 ARM 上则没有这个概念。x86 亦没有。
	这种技术手段主要用在早期没有分支预测的流水线 RISC 上，现代 RISC 实现早就
	可以在流水线的第 2 级利用分支预测确定跳转的目标，分支延迟槽也就失去了原
	来的价值，但为了软件上的兼容性 MIPS 和 SPARC 还是作了保留。

MIPS指令可以分成以下各类：
	空操作no-op
	寄存器/寄存器传输
	常数加载：作为数值和地址的整型立即数
	算术/逻辑指令
	整数乘法、除法和求余数
	整数乘加
	加载和存储
	跳转、子程序调用和分支
	断点和自陷
	cp0功能：CPU控制指令
	浮点
	用户态的受限访问：rdhwr和synci
注：64位版本以d开头表示，无符号数以u结尾，立即数以i结尾，双子操作以d结尾，字以w

第2章	MIPS体系结构
	计算机也是如此——如果你有某种极端的或者超常规的需求，实现的细节就对你很重
	要了。
	一般而言，一个CPU的体系结构包括一组指令集加上一些寄存器的知识。指令集与
	体系结构这两个术语基本上是同义词。ISA(Instruction Set Architeture指令集
	体系结构)。
寄存器：
	0	zero	永远返回0
	1	at	(assembly temporary汇编暂存)保留给汇编器使用
	2-3	v0,v1	子程序返回值,用来存放子程序返回的非浮点值。如果要返回的值
			太大，这两个寄存器放不下编译器将会通过内存来完成。
	4-7	a0-a3	(arguments)子程序调用的前4个参数
	8-15	t0-t7	(temporaries)临时变量，子程序使用时无需保存
	24-25	t8-t9	
	16-25	s0-s7	子程序寄存器变量；子程序写入时必须保存其值并返回前恢复原
			值，从而调用函数看到这些寄存器的值没有变化。
	26-27	k0,k1	保留给中断或自陷处理程序使用；其值可能在你眼皮地下改变
	28	gp	(global pointer)全局指针；一些运行系统维护这个指针以便于
			存取static和extern变量.
	29	sp	(stack pointer)堆栈指针
	30	s8/fp	第九个寄存器变量；需要的子程序可以用来做帧指针(frame po-	fp帧指针
			inter)
	31	ra	子程序的返回地址,永远由正常函数调用指令jal存放返回地址。
--------------------------------------------------------------------------------	
	s0-s8	依照约定，必须保证这些寄存器的内容在子程序返回时要和子程序入口的
		值相同，要么在子程序里不用这些寄存器，要么把它们保存在堆栈上并在
		子程序返回时恢复。这些约定使得这些寄存器非常适合作为寄存器变量，
		或存放一些在子程序调用期间必须保存的值。

	程序计数器:
	用于存放下一条指令所在单元的地址的地方。单片机及汇编语言中常称作PC（Pr-
	ogram Counter）。

	gp:用于两个不同目的。对于linux程序使用的一类位置无关的代码PIC，本模块外的
	代码和数据引用都要通过一个称为全局偏移量表GOT(global offset table)的指针
	表。gp寄存器用来维护指向该表的指针。
	在常规的非PIC代码(在简单的嵌入式系统中会用到)中，gp有时用来指向一个链接时
	确定位置的静态数据中部。这意味着，利用gp作基指针，对于在gp指针前后32k范围
	内的数据存取，只需要一条指令就可完成。
	如果没有全局指针，存取一个静态数据区域的值需要两条指令：一条是获取由编译
	器和装载程序计算去的32位地址常量的高位，另外一条才真正存取数据。
	要建立相对于gp的地址应用，编译器在编译时刻必须知道一个数据链接后的内存地
	址在64K范围之内。实际上这是不可能知道的，只能靠猜测。通常的做法是把小的(
	八字节以内的)全局数据项放在gp的区域内，如果还是太大，就让链接器发出警告。

	sp:堆栈指针的上下移动需要显式的通过指令来实现，因此MIPS通常只在子程序入口
	处把sp调整到子程序中间堆栈可能达到的最低点，从而编译器可以通过相对与sp的固
	定偏移量来存取堆栈变量。

	fp:帧指针，也叫做s8.如果由于某种原因编译器或程序员不能或不愿计算相对于堆栈
	指针的偏移量，子程序可以通过帧指针来记录/跟踪堆栈的情况。

	ra:在任何一个子程序入口处，ra寄存器中保存着返回地址——因此典型的子程序都以
	一条jr ra指令结尾。理论上讲，这里可以使用任意寄存器，但是一些复杂的CPU因
	为采用优化技巧(分支预测)，使得jr ra时效果会更好。

整数乘法部件及寄存器 lo hi
	因为乘法的结果返回没有快到能自动供随后的指令使用的程度，乘法的结果寄存器
	总是互锁的。在乘法运算完成之前任何企图读取结果的操作都将导致CPU停下来等
	待乘法操作结束。
	整数乘法器也可以执行两个通用寄存器的除法操作。lo(商),hi(余).
	乘法要用4-12个周期，除法要用20-80个周期。

加载与存储：寻址方式
	MIPS只有一种寻址方式，任何加载或存储操作的机器指令都可以写成：
	lw $1, offset($2)
	可以用任何寄存器作为目标和源寄存器。偏移量offset是一个有符号的16位的数字
	(-32768 32767);加载所用的程序地址是$2寄存器的值与offset的和。这种寻址方
	式一般已足够存取C语言结构体的一个成员。

寄存器与寄存器的数据类型
	MIPS CPU可以在一次操作中装载或存储一到八个字节。				指令是4四字节对齐的，数据的话?
	long long	dword	8	ld--->d
	int		word	4	lw--->w
	short		halfword 2	lh--->h
	char		byte	1	lb--->b
整数数据类型
	字节byte和半字halfword的加载方式有两种。符号扩展的指令lb lh指令将数据值存
	放在32为寄存器的地位，并将高位用符号位（字节的位7，半字的位15）的值来填充。

	无符号的指令lbu和lhu用零来扩展数据，将数据值加载到32为寄存器的地位中,并用
	零来扩充高位。
	例如：假设寄存器t1中是存储器中一个byte字节宽度数据的地址，该处存放的值为
	0xFE(有符号数-2或无符号数254)，那么
	lb	t2, 0(t1)
	lbu	t3, 0(t1)
	执行之后，寄存器t2的值为0xFFFF FFFE(有符号数-2)，t3的值会是0x0000 00FE(有
	符号数或无符号数254)

未对齐的加载和存储
	MIPS体系结构中，正常的加载和存储必须对齐；半字只能从双字节的边界加载；字
	只能从四字节的边界加载。一个对非对齐的地址的加载指令会导致自陷.或者按照宏
	命令（由多个命令组成）。
	linux-gcc也会按照类型对齐uint16_t双字节对齐，所以链接后它的地址肯定是2(按
	字节寻址）的倍数,int是4的倍数。

内存中的浮点数据
	l.d	$f2, 24(t1) ==
	lwc1	$f2, 24(t1)
	lwc1	$f3, 28(t1)
	在64为CPU上，任何一个遵循MIPS/SGI规则的C编译器都将八字节长的双精度浮点变量
	对齐到八字节的地址边界上。32为硬件并没有这样的对齐要求，对齐仅仅是为了向后
	兼容。

汇编语言的合成指令：
GNU的汇编器会合成一些指令，只需要写一个li(加载立即数)指令，汇编器会知道什么时候要生成两条机器指令。要明确区分合成指令与机器指令。
---------------------------------------------------------------------------------------------------------------------------------------
汇编器所做的：
	32位立即数的加载，写一个加载任何值的代码，汇编器将会把其拆开成为两个指令，
	分别加载这个数据的高半部分和低半部分。

	从内存地址加载，写一个加载驻留内存的变量的代码。汇编器通常会将这个替换成
	两个指令，先是一条把变量地址的高位加载到临时寄存器的指令，接着是一条以该
	变量的低位为偏移量的加载指令。当然这不适用于C语言函数内部定义的局部变量，
	局部变量是通过寄存器或堆栈实现的。

	对内存变量的快速存取，有些c程序包含许多对static和extern变量的引用，对他们
	加载/存储用两条指令开销太大了。有些编译系统，在编译/汇编时(最常见的做法是
	汇编器选择占用八个字节或更小空间的变量)选择一些变量，并将他们一起存放到最
	后大小在64K字节以内的一个内存区。然后运行时系统初始化一个寄存器——习惯上用
	$28也就是gp——来指定该内存去的中间位置。对这些变量数据的加载和存储现在就可
	以通过一条相对gp寄存器寻址的加载或存储指令来完成。

	更多类型的分支条件：汇编器合成了一整套根据两个寄存器的算术运算结果来进行
	条件分支的指令。

	同一指令的简写或多种不同的写法：像not和neg这样的单目运算，是通过与永远是
	零值的寄存器$0的nor或sub来实现的。你还可以把一个三个操作数的指令写成两个
	操作数的形式，汇编器将会把结果写到给出的第一个寄存器中

	隐藏分支延迟槽：在正常的情况下，汇编器如果看出将写在分支之前的指令移动到
	延迟槽没问题的话，就会这样做。因为汇编器能够看出的情况不多，所以不太善于
	填充延迟槽。有一条汇编伪指令.set noreorder可以用来告诉汇编器不要自动移动
	指令，由程序员人工控制。

	隐藏加载延迟槽：有些汇编器会检测到紧接加载指令后试图使用加载结果的指令，
	如果行的话可能会上下移动一条指令。

	未对齐的数据传送：非对齐的加载/存储指令(ulh, ulw等待)能正确的存取半字和
	字数据，即使目标地址是未对齐的。

	其它流水线校正：一些指令(比如使用整数乘法单元的指令)在一些老的CPU上还有
	些额外的限制。如果你用的是这些老的CPU，就会发现汇编器能帮上忙。

	如果想要将汇编源代码与内存中的指令对应起来，需要借助反汇编工具。
	(反汇编：把执行文件，反汇编成汇编语言)
--------------------------------------------------------------------------------
MIPS I到MIPS64 ISA：64位和其他的扩展:
											??怎么扩展的？寄存器位数，寻址，指令变化。
运行在MIPS32兼容状态下时，寄存器的高32位应该存放什么?
--------------------------------------------------------------------------------
基本地址空间：
	在MIPS CPU里，程序中的地址绝不会和芯片的物理地址相同(有时变化很小，但并不
	相同).我们分别称之为程序地址和物理地址。
	MIPS CPU可以运行在两种特权级之一上：用户模式和核心模式，就是用户态和核心
	态。但是MIPS体系结构的一个特点就是从核心态到用户态的变化并不改变操作的行
	为，只是又是某些操作被认为是非法的。在用户态，地址最高位为一的任何程序地
	址都是非法的并会导致自陷。

在32位下：程序地址空间划分为四大区域，每个区域有一个传统的(完全没有意义的)名字。
	根据地址所处的区域不同，处理也不同：
		 ------------------------
                | Mapped         (kseg2) |   1 GB
                |                        | 
0xc000 0000	 ------------------------
                |Unmapped uncached(kseg1)|   512MB
0xa000 0000	 ------------------------
                | Unmapped cached(kseg0) |   512 MB
0x8000 0000	 ------------------------
                | 32-bit userspace kuseg |   
                |                        |   2 GB
                |                        |   
                |                        |   
0x0000 0000	 ------------------------

kuseg 0x0000 0000 - 0x7fff ffff(低端2G):这些地址是用户态可用的地址。在有MMU的机器
	里，这些地址将一概被转换。除非MMU已经设置好，否则不应该使用这些地址，对于
	没有MMU的机器，这些地址的行为与具体实现机器相关。
kseg0 0x8000 0000 - 0x9fff ffff(512M):只要把最高位清零这些地址就会转换成物理地址,
	映射到连续的低端512MB的物理地址。因为这种转换极为简单，常常称这段地址为"
	非转换"的区域，但其实不然。该区域的地址几乎总是要通过高速缓存来获取，所以
	在高速缓存适当初始化之前，不能使用。这个区域在无MMU的系统中用来存放大多数
	程序和数据，再有MMU的系统中用来存放操作系统核心。
kseg1 0xa000 0000 - 0xbfff ffff(512MB):这些地址通过把最高三位清零的方法来映射到物
	理地址，重复映射到了低端512M的物理地址。但是这一次不经过高速缓存。
	kseg1是唯一的在系统重启时能正常工作的地址空间。这也是为什么复位时的入口点
	(0xbfc0 0000)放在这个区域。入口点相应的物理地址是0x1fc0 0000.把入口点地址
	置为0xbfc0 0000是无法启动的。这个区域去存取初始的程序rom，最好不要把这些
	东西映射到物理内存的低512空间之外。
kseg2 0xc000 0000 - 0xffff ffff(1G):这块区域只能在核心态下使用并且要经过MMU的转换。
	在MMU设置好之前，不要存取该区域。除非你在写一个真正的操作系统，否则来说没
	有理由用kseg2.
---------------------------------------------------------------------------------------------------------------------------------------
简单系统的寻址：
	mips的程序地址从来不会和物理地址简单相等。但对于简单的嵌入式软件而言可能
	只用到kseg0和kseg1的地址，他们和物理地址有着非常简单的映射关系。
	从0x2000 0000(512 M)开始向上的物理地址空间在上述简单情形下没有任何的映射，
	大多数简单的系统所有地址都映射到512M以下。但是如果真的需要，你可一通过设
	置存储器管理单元的(TLB)的方式，或者使用64位CPU的一些额外空间，来存取512M
	以上的物理地址。
--------------------------------------------------------------------------------
核心与用户特权级：


--------------------------------------------------------------------------------
64位的地址映射：
	MIPS地址总是通过一个寄存器的值加上一个16位的偏移量形成的。在64位MIPS CPU
	里，寄存器中总是64位的值，因此就有64位的程序地址。
0xffff ffff ffff ffff___ --------------------------
0xffff ffff e000 0000   | supervisor mapped(kseg2) |
                        | kernel                   |
0xffff ffff c000 0000	 --------------------------
0xffff ffff a000 0000   | "unmapped" cached(kseg1) |
                        | "unmapped" cached(kseg0) |
0xffff ffff 8000 0000	 --------------------------	__________________
0xc000 00ff ffff ffff   | _ _ _ _ _ _ _ _ _ _ _ _  |
	xkseg           | kernel-accessible   2^40 |
                        | byte or more             |
0xc000 0000 0000 0000___ --------------------------
                        | -                      - |
                        | window on  physical  mem |
0x9800 0000 0000 0000   | (uncached)               |
                        | -                      - |
	xkphys		 --------------------------
                        | window on  physical  mem |    Inaccessible with 32-bit
                        | (cached)                 |    pointers(so only found in
0x9000 0000 0000 0000 	 --------------------------     64-bit CPUs)
0x8000 0000 0000 0000___| - 	                 - |
0x7fff ffff ffff ffff	 --------------------------
                        | - 	                 - |
	xsseg		 --------------------------
                        | supervisor    accessible |
0x4000 0000 0000 0000   | 2^40 byte or more        |
0x3fff ffff ffff ffff___ --------------------------
                        | - 	                 - |
			 --------------------------
	xuseg           | more      user     space |
                        | to 2^40 byte or more     |
			 --------------------------	____________________
                        | 32-bit user space(kuseg) |
                        | 2 Gbytes                 |
0x0000 0000 0000 0000___ --------------------------
————————————————————————————————————————————————————————————————————————————————
流水线可见性：
	指令遇险:
	前一个CP0操作可能会影响后一个指令的取指的情形，称之为指令遇险(instructi-
	on hazard);
	执行遇险，遇险防护

协处理器0：MIPS处理器控制
	除了通常的运算功能之外，任何处理器都需要一些部件来处理中断、配置选项以及
	需要某种机制来监控诸如片上高速缓存(cache)和定时器等功能。
	CP0作用：
	CPU配置、高速缓存控制、异常/中断控制、存储管理单元控制、杂项。
	k0,k1(通用寄存器$26-27)，只是两个(由软件约定)预留下来的用户异常处理代码中
	通用寄存器。预留至少一个通用寄存器是必要的。
		MIPS CPU 控制寄存器
	寄存器助记符	cp0寄存器编号	描述
	SR		12		状态寄存器(status register)，由可写的控制
					位域(一反常规)组成。包括确定cpu特权等级、
					那些终端引脚使能和其它的CPU模式等位域。
	cause		13		导致异常或中断的原因
	...
	
	CPU控制指令：
	mtc0 	s, <n> #把数据传送到协处理器0
	把cpu通用寄存器s的内容传送到协处理器0寄存器n，数据为32位(即使在64位cpu里，
	很多CP0寄存器也只有32位长，但对于少数长于cp0寄存器有一条dmtc0指令).这是
	设置cpu控制寄存器的唯一方法。

	在汇编程序里直接引用控制寄存器的编号来是不良习惯；通常应该使用助记符。大
	多数工具链把这些名字定义在一个C风格的include文件中，然后用c的预处理作为
	汇编器的前端。

	从CP0控制寄存器中取出数据与之相反：
	mfc0	d, <n> #从协处理器0取出数据
	通用寄存器d装入CPU控制寄存器n的值。这是查看控制寄存器值的唯一方法(类似
	也有dmfc0用于少数64位宽的寄存器)
	通常要更新控制寄存器内部的单个域---如SR状态寄存器，通常代码是这个：
	mfc0	t0, SR
	and	t0, <要清零的位的反码>
	or	t0, <要置1的位>
	mtc0	SR, t0

	异常基本问题:
	异常可以在运行用户(低特权级)代码是发生，但是异常处理运行在高特权级。因此	软件异常，系统调用
	一：如果在控制返回用户程序之前特权级就降低了，马上就会因为违反特权级而得
	到一个致命的二次异常；二：如果在降低特权级之前先回到用户代码，那么一个恶
	意的无特权的程序就有可能得到机会以内核特权级运行一条指令。
	eret来完成特权级切换的任务。

3.2控制寄存器的使用
	上电后：需要设置SR来使CPU进入一个可工作的状态，以便能够顺利执行随后的引
	导过程。硬件通常的做法都是在复位后让许多寄存器的位为未定义。

	处理任意异常：早期的MIPS cpu中任何异常都调用一个固定入口地址的公共的“通
	用异常处理程序”。后来有越来越多的理由支持对不同的目的使用分开的异常处理
	程序。
	在异常入口处，不报存任何程序寄存器，只有返回地址被存在EPC。MIPS硬件队于
	堆栈一无所知。在任何情况下一个安全操作系统拥有特权的异常处理程序不能假定
	用户级代码的正确性————特别地，它不能假定栈指针有效或者栈空间可用。

	从异常返回：控制最终必须返回到在异常入口处保存到EPC中的地址。不管是什么
	异常，返回时都要把SR寄存器调整回原来的值、恢复用户态特权，允许中断以及消
	除异常的一般影响。最后异常返回返回指令eret合并完成了返回用户空间和复位S
	R（EXL）的功能。

	中断：SR用来调整中断掩码，决定那些中断被赋予比当前更高的优先级。硬件没有
	提供中断优先级，但是软件可以随意。 
	纯粹为了引发异常的指令：这些指令常用于（系统调用、断点调试以及某些指令仿
	真等）。所有的MIPS CPU都实现了break和syscall指令；有些实现还加了额外的指
	令。
3.3CPU控制寄存器及其编码
状态寄存器SR：
	MIPS CPU仅有的几个模式位定义在高度紧凑的状态寄存器SR的域中。
	31   28 27 26 25 24 23 22  21 20  19  18 17 16 15   10 9  8  7  6  5  4  3  2   1   0
	CU3-0   RP FR RE MX PX BEV TS SR  NMI 0  Impl  IP7 -2 IP1-0  KX SX UX  UM R0 ERL EXL IE
							IPL		    KSU

	CU3-0: 每个位分别代表协处理器3-0的协处理器使能。
	RP: 减小功耗，可以减低CPU的运行频率、电压或者同时减低。
	FR: 模式切换设为1则全部32个双倍宽度的浮点寄存器软件都可见；设为0让他们模
	    拟MIPS I的成对32位浮点寄存器的行为。
	RE: 反转用户态下的尾端设置。
	
	BEV:启动时异常向量
	TS:TLB关闭

	UX,SX,KX:三个不同的（用户、管理、核心）特权级各自有不同的位。当相应位置位
		后最为常见的内存地址转换异常(TLB未命中)被重定向到不同的入口点，在
		那里软件将处理64位地址。
	KSU:CPU特权级0是核心级，1是管理级，2是用户级。

	ERL:错误级
		ERL赋予了一个特殊的任务，一旦其置位，就会深度影响处理器的行为；对
		正常的用户空间转换的地址的所有访问都将消失，从0到0x7fff ffff的程序
		地址变成一个映射到相同物理地址的不做高速缓存的窗口。

3.3.2 原因寄存器（Cause）
	BD 分支延迟：
	EPC保存的是异常处理完后的返回地址，正常情况下，这也指向异常受害指令。
	但是如果发生异常的指令实在一条转移指令的延迟槽里，EPC得指向那条转移指令；
	重新执行转移指令没有什么害处，但如果返回到延迟槽指令本身，转移就不会发生
	从而这个异常将破坏背中断的程序。
	只要异常发生在延迟槽的指令，cause(BD)就会置位,EPC就指向指令分支。如果想分
	析异常受害指令，只要看cause(BD)(如果cause(BD)==1，那么该指令位于EPC+4）就
	知道了。
3.3.3 异常返回地址（EPC）寄存器
	这只是一个保存异常返回点的寄存器。导致（或者遭受）异常的指令地址存入EPC，
	除非cause寄存器的BD位置位了，这种情况下EPC指向前一跳（分支）指令。如果CP
	U是64位那么EPC也是64位。
3.3.4 无效虚拟地址（BadVaddr）寄存器
	这个寄存器保存引发异常的地址；在发生MMU 相关的异常时、在用户程序试图访问
	kuseg 以外的地址时、或者地址没有正确对齐时，该寄存器被设置。发生其他任何
	异常后它的值都是未定义的。如果cpu 是64位的，BadVAddr也是64位。
3.3.5 片上定时器
	count是一个连续计数的32位递增计数器，CPU的流水线频率的同频、半频或者（很
	少见）其他分频运行。可以通过获取硬件寄存器来找出计数器频率。

	count计数到最大的32位无符号数值时，就溢出而回到零。你可以读取count获取当
	前的“时间“。也可以随时写入count。

	compare是一个32位的可读写的寄存器。当count计数增加到等于compare 中的值时
	中断信号就会升起。中断信号一直保持有效，直到下一次写入compare。

	要产生一个周期性的中断，中断处理程序应当总是以固定的增量增加compare （而
	不是增加count ，因为那样周期就会因为中断延迟而略微延长）。软件需要检查这
	中可能性——一个迟到的中断响应可能把compare设置成一个count已经过了的值；典
	型的做法是在写完compare之后 重新读取count的值。
3.3.6 Config寄存器：cpu资源信息和配置
	mips32/64定义了4个标准寄存器给初始化软件使用：config和config1-3。
	AT 是mips32还是mips64：
	0	mips32
	1 	mips64指令集但是mips32地址空间映像
	2 	mips64指令集全地址空间
	
	MT MMU类型:
	0	没有（none）
	1	mips32/64标准的TLB
	2	BAT类型
	3	MIPS32标准的FMT固定映射							MMU类型:决定TLB

	VI
	置1代表L1一级指令高速缓存I-cache以虚拟地址（即程序地址）索引和标记。虚
	拟的I-cache要求操作系统作特殊的处理/对待。
CP0遇险：
	MIPS32/64根据依赖指令受影响的是哪个阶段区分两种不同的CP0遇险。指令遇险
	是指那些依赖的指令在读取一个CP0 寄存器值的时候受到影响的情形。指令遇险
	是指那些依赖的指令在其最早期就受到影响的情形——最坏的情形是，在内存或高
	速缓存取指开始就已经受到影响。
———————————————————————————————————————————————————————————————————————————————
MIPS高速缓存工作机制
	高速缓存的工作就是将内存中最近读写的一部分数据保留一个备份，使这些数据
	能快速存取并返回给CPU 。对于一级高速缓存，必须在固定的时间内完成存取以
	保证流水线的连续运行。

	MIPS CPU指令和数据各自有相应的一级高速缓存：I-cache D-cache.这样读取一
	条指令和存取一个数据的操作就能同时进行。

	直接映射高速缓存：
	地址低位 --- 映射缓存tag，如果只有一个数据直接命中，如果有多个就match		组相联高速缓存
	地址高位，匹配就hit。

	透写高速缓存 写缓冲器：
	在主存控制器进行准备和写入数据的同时，将要写入主存的数据及其地址先保存
	到一个队列。然后由主存控制器自己取得这些数据并完成写操作。这个临时保存
	写操作的地方被组织成一个先入先出的（FIFO）的存储区，称为写缓冲器（wri-
	te buffer）。

	回写高速缓存:
	要写的数据只写到高速缓存中，并且对应的那条缓存要做一个标记，保证我们以
	后不会忘记把它写回到主存中（一个需要写回到主存的高速缓存行，称之为dir-
	ty 或者 modified）。

	纯粹工作物理地址方式下的高速缓存很容易管理。但原始的程序地址（即虚拟地
	址）可以更早的开始高速缓存匹配，让系统跑得稍微快一点。
	许多MIPS CPU都采用程序地址为一级高速缓存提供快速的索引。但是却采用物理
	地址标记每一个高速缓存行，而不是采用程序地址加地址空间标识符。

	在DMA 设备从内存取数据之前，如果一个设备从主存中取出数据，它取得正确的
	数据就至关重要。如果数据高速缓存是回写式的，并且程序最近已经写了一些数		几路相联?
	据，那么很可能其中一些新正确的数据还保留在D-cache 高速缓存中而没哟写回
	到主存中去。CPU当然无法发现这个问题：cpu查看主存地址时，会从高速缓存中
	得到新的正确的数据。
	所以在DMA设备从内存中开始读数据前，如果被读取的区域还有数据在D-cache中
	就必须写回到主存。

	大多数现代的MIPS CPU拥有回写式、虚拟索引的、物理标签、两路或者四路组相		五级流线中的MEM和WB。
	联的一级高速缓存。高速缓存管理通过一条特殊的cache指令进行。

	一些基本的缓存管理操作：
	1. 作废某块高速缓存区域
	2. 回写一段地址区域
	3. 作废整个高速缓存
	4. 初始化高速缓存

	高速缓存初始化和Tag/Data寄存器
	MIPS32/64定义了一对32位寄存器TagLo和TagHi。TagHi常常不是必要的；如果你
	的物理地址空间不超过36位，TagLo通常就能为整个标签提供足够的空间。

	由于高速缓存是虚拟地址索引、物理地址标签的，所以不同虚拟地址对同一物理
	地址存取就可能造成高速缓存重影。这时候交给软件保证的就是对应于同一个物
	页面的不同程序地址间的距离为L1高速缓存每路最大容量的整数倍。如果操作系
	统在设置多个虚拟地址到同一个物理页的映射时小心地保证虚拟页地址的间距为
	L1高速缓存最小容量的整数倍，就很难想象还会出问题。

5.异常、中断及初始化
	在MIPS中，中断、自陷、系统调用以及其他打断程序正常执行流的事件统称异常
	都采用同一中机制处理。

	外部事件：在CPU核之外的事件---即来自于真实的“连线“上的输入信号。这就是
	中断。中断用来让CPU 的注意转到某些外部事件：这是要同时处理多个事件的操
	作系统所必不可少的特性。
	中断是唯一由CPU 正常指令流以外的事件引起的异常条件。因为中断不是小心就
	能避免的，所以必须有某种软件机制在必要时禁止中断。

	存储器地址转换异常：当某个地址需要转换但是硬件不能有效转换时，或当写一
	个有写保护的页时，会发生这个异常。

	其他需要内核干预的非常情况：其中就是浮点指令导致的条件，此时硬件无法处
	理某些困难和少见的操作符和操作数的组合而寻求软件仿真服务。
精确异常:

启动：
	复位和异常完全一样，是一种不会返回的异常。
	CPU响应复位时从地址0xBFC0 0000处开始取值，这是不用高速缓存的kseg1 区的
	物理地址0x1FC0 0000.
	复位之后，CPU控制寄存器有足够的状态已经确定，可以让CPU执行非常非高速缓
	存的指令。
	刚刚够的状态：
	SR只能保证三样东西：CPU 处于核心态；中断是禁止的；异常被指引到不经高速
	缓存的入口点——即SR（BEV）=1.在现代的CPU 上，保证前两个（以及更多）的条
	件的典型做法就是将异常模式位SR（EXL)置位，把复位看作异常，其实已经隐含
	了这一层意思。

	高速缓存处于随机的、无意义的状态，所以从高速缓存的加载可能不读取存储器
	而直接返回垃圾。

	TLB处于随机的状态，在初始化之前绝对不能访问（在有些CPU上硬件对TLB 表项
	重复的可能风险只是最少的保护，结果可能是TLB 关闭，只能通过再一次复位才
	能修复）。
启动应用程序：
	要想能够启动一个C语言的应用程序，需要有可以写入的存储器。
	首先，需要堆栈空间。分配足够大的一块可写的内存并且把sp寄存器初始化为该
	块存储器地址的上届（对齐到八字节的边界）。				这里为什么要对齐到八字节边界？

TLB/MMU硬件及其作用
	TLB 是把你的程序用的地址（程序地址或虚拟地址）转换成为访问存储器的物理
	地址的硬件。操作系统对于内存转换的控制是所有软件安全特性的关键。

	转换表中每一项含有一个页的虚拟地址（VPN即虚拟页号）和一个物理页地址（P
	FN代表页帧号）。当程序给出一个物理地址时，该地址和TLB中每个VPN做比较，
	如果和某一项匹配就给出相应的FPN。TLB是一种称之为相联存储器或者内容寻址
	的存储器——不是按照索引来选择而是根据内容来选择某一项。

	有一组标志位和每个PFN 一起存储并一起返回，标志位让操作系统可以指定某一
	页为只读或者指定某页的数据是否可以高速缓存。

	大多数现代的MIPS CPU采用双倍存储，每个TLB 项容纳一对相邻的虚拟页面对应
	的两个单独的物理地址。
				TLB数据项
	entryhi		pagemask	entrylo0	entrylo1
	VPN2|ASID	Pagemask|G	PFN|flags VDC	PFN Flags|VDC
	--------------------------	-----------------------------
	input(8k of virtual space)	output(pair of physical pages)

	所有的TLB表项的写入或者读取都要通过寄存器EntryHi、EntryLo-1和 PageMask
	来进行。

MIPS指令
	C：
	int strcmp(char *str1, char *str2)
	{
		char c1, c2;
		do {
			c1 = *str1++;
			c2 = *str2++;
		} while (c1 != 0 && c2 != 0 && c1 == c2);

		return c1 - c2;
	}

	在汇编代码中，C函数的两个参数从a0 a1寄存器中传送（约定）。这样的简单的
	例程可以随便使用临时寄存器t0等等而无需保存和恢复，所以选择临时寄存器存
	放临时变量。函数有一个返回值，按照约定返回时要存放进v0寄存器。
	strcmp:
	1:
	lbu	t0, 0(a0)
	addu	a0, a0, 1
	lbu	t1, 0(a1)
	addu	a1, a1, 1

	beq	t0, zero, .t01
	beq	t1, zero, .t01
	beq	t0, t1, 1b

.t01:
	subu	v0, t0, t1
	j	ra

	as1:是一个数字标号，许多汇编器把它当作局部标号。你在程序中可以有许多标
	号都叫做1;1f指下一个标号，1b指上一个。这样，就不用为每个仅在局部使用的
	标号都发明一个新的唯一名字。
汇编指令及其意义：
	三操作数指令双操作形式：
	addu  $1, $2	#$1 = $1 + $2

	所有可能的load/store地址格式（addr）：MIPS机器指令总是用一个寄存器的内
	容加上一个16位的有符号的偏移量生成load/store操作的地址

MIPS指令格式和寻址方式
	特点：采用32位定长指令字，操作码字段也是固定长度，没有专门的寻址方式字
	段，由指令格式确定各操作数的寻址方式。
(1)R—型指令
	OP rs rt rd shamt func
	操作码OP为“000000”，操作类型由func字段给出，若是双目运算类指令：rd=rs 
	func rt;移位指令，根据shamt字段给出的移位数，将rt 的内容进行移位，结果
	送至rd。
(2)I—型，立即数型 
	OP rs rt 立即数
	1.双目运算：rt=[rs]+立即数；
	2.Load指令：rt=[[rs]+立即数]
	3.Store指令：和上面的过程反过来
(3)J—型
	OP 直接地址
	无条件跳转指令，内存地址=26位直接地址+PC高四位+最后添两个‘0’

	在整数乘除的机器码中，由单独分开的指令分别发起运算和提取结果。但是除法
	的汇编宏指令的名字div，和基本的机器码指令的名字相同。

MIPS汇编指令（按字母次序排列)
	abs	d, s => d = s < 0 ? -s : s
		sra	$at, s, 31	# -9 -> 1111 1111 1111 0111>> 31=1111 1111 1111 1111  = -1(补码)
		xor	d, s, $at	# 1111 1111 1111 0111 ^ 1111 1111 1111 1111 = 0000 0000 0000 1000 = 8
		subu	d, d, $at	# 0000 0000 0000 1000 - (-1) = 0000 0000 0000 1001 = 9

	add	d, s, j => d = s + (signed)j 溢出时自陷，很少用 
		addi	d, s, j

	add	d, s, t => d = s + t 溢出时自陷，很少用

	addu	d, s, j => d = s + (signed)j j可以超过-32768<= j < 32768的范围，但是生成的代码会复杂
		addiu	d, s, j

	addu	d, s, t => d = s + t

	and 	d, s, j => d & (unsigned)j 仅用于0<= j < 65535对于更大的数，要生成额外的指令
		andi	d, s, j

	and	d, s, t => d = s & t

	b 	lable => goto label
		beq	$zero, $zero, offs

	beq	s, t, label => if (s == t) goto label

	beqz	s, label => if (s == 0) goto label
		beq	s, $zero, offs

	bge	s, t, label => if ((signed)s >= (signed) t) goto label
		slt at, s, t => if (s < t) at = 1; else at = 0
		beq at, $zero, offs

	bgeu	s, t, label => if((unsigned)s >= (unsigned)t) goto label;

	bgez	s, label => if (s >= 0) goto label

	bgezal	s, label 如果(s >= 0)调用label(),但是返回地址无条件地保存在寄存器ra($31)中

整数乘法、除法和求余数								# 补码的运算，运算器的设计
	结果寄存器是互锁的；如果试图在结果出来之前读取，CPU 就会停下来等待数据
	到达。
	MIPS公司的汇编器会把乘以一个常数或除以2 的常数次幂的计算转换成为适当的
	移位、掩码。

	strcmp(char* a0, char* a1)
	{
		char t0, t1;
		while(1) {
			t0 = a0[0];		// 两个加载延迟:对应于两次数组下标操作
			a0++;
			t1 = a1[0];
			a1++;
						// 两个if条件分支延迟
			if (t0 == 0)
				break;		// 每次分支和加载都引入了一个延迟槽，而循环体
			if (t0 != t1)		// 中没有足够的工作来填满它们。
				break;
		}				// 在每对字节的比较(对应while语句结束的大括号)
		return (t0 - t1);		// 时都有一个强制的循环结尾分支。
	}
汇编之前的改进：
	1. 每次循环作两次比较
	2. 把其中一次加载移到循环的结尾
	这样加载和分支的延迟槽都可以填上有用的工作.

	int strcmp(char *a0, char *a1)
	{
		char t0, t1, t2;

		/* first load moved to loop end,
		   so load for first iteration here */				.set noreorder
		t0 = a0[0];							lbu 	t0, 0(a0)

		while (1) {							1:
			/* first byte */
			t1 = a1[0];						lbu	t1, 0(a1)

			if (t0 == 0)						beq	t0, zero, .t01
				break;
			a0 += 2;						addu	a0, a0, 2

			if (t0 != t1)						bne	t0, t1, .t01
				break;

			/* second byte */
			t2 = a0[-1];	/* We already incremented a0 */		lbu	t2, -1(a0)
			t1 = a1[1];	/* didn't increment a1 yet */		lbu	t1, 1(a0)

			if (t2 == 0)						beq	t2, zero, .t21
				/* label t21 in assembler */
				return t2 - t1;
			a1 += 2;						addu	a1, a1, 2 /* :w
			if (t1 != t2)						beq	t2, t1, 1b
				/* label t21 in assembler */
				return t2 - t1; /* 原书错误 */
			t0 = a0[0];						lbu	t0, 0(a0)
		}								.t21:j	ra
		/* label t01 in assembler */					subu	v0, t2, t1
		return t0 - t1;							.t01:j	ra
										subu	v0, t0, t1
	}									.set reorder
										END(strcmp)
	move d, s汇编器汇编成为：or d, zero, s

	如果立即数的值太大无法放进机器指令的16位操作数域，那么汇编器将再度出面
	帮忙。她自动将常数装进临时寄存器at/$1然后用它来进行操作：
	addu	$4, 0x12345 	=> 	li at, 0x12345
					addu	$4, $4, at
------------------------------------------------------------------------------
目标文件在存储器映像中的布局
.text
.rdata
.data
.lit4 .lit8	浮点隐含常数，不能用汇编来写这些区的名称。它们是汇编器隐含生成的
		用来容纳作为li.s和li.d宏指令到参数的浮点常数。
.bss .comm .lcomm	
	这些也不用汇编指示。用来收集C 模块中声明的所有静态或者全局的未初
	始化的数据。C 语言有一个特性就是不同模块中的多个同名的定义是可以
	的，只要其中初始化的不超过一个就行。.bss就是用来收集处处都没有初
	始化过的数据。
	非初始化一词实际上用词不当。在C 语言中没有明确初始化的静态或者全
	局变量在程序开始的时候都会清零——这是操作系统或者程序启动代码的
	工作。
.sdata、小数据和.sbss
	想要把小的数据项分开的工具链把这些区作为.data和.bss 区的补充或替
	代方案。
.section
	开始一个任意命名的区，并提供控制标志。

栈
	通过设置sp寄存器到可用内存的顶部（对齐到八字节的边界）来定义的。
堆
	是用象malloc()等函数使用一个全局变量指针来定义的；该变量常常初始
	化为end符号，是由链接器计算出的所有声明的变量使用的最高地址。

软件和尾端：
	#include <stdio.h>
	int main(void)
	{
		union {
			int as_int;
			short as_short[2];
			char as_char[4];
		} either;
		
		either.as_int = 0x12345678;
		
		if (sizeof(int) == 4 && either.as_char[0] == 0x78) {
			printf("Little endian\n");
		}
		else if (sizeof(int) == 4 && either.as_char[0] == 0x12) {
			printf("Big endian\n");
		}
		else {
			printf("Confused\n");
		}
	}

硬件和尾端：
	尾端不一致的总线布线连线
	尾端可配置的接线
	-----------------------------------------------------------------------------
	MIPS CPU的双尾端软件：
	MIPS CPU 改变尾端并不需要做太多。指令集中唯一能够认识不足32为对象部分就是部分
	字装载和存储。
	lbu	t0， 1(zero)
	获取位于程序字节地址为1 的字节，把他加载到寄存器t0的最低有效位(0-7)，把寄存器
	的其余位都填0。这个描述是尾端无关的，但是在大尾端模式下，装进寄存器的数据将取
	自CPU数据总线的16-23位；在小尾端模式，字节从CPU总线的8-16为加载。

mips-asm gcc c:
inline:
	与__ __ 包裹它的描述一致，告诉寄存器对这个函数的调用应当用其函数体来替
	换。加上static表示该函数不需要公开给其他模块使用，所以并不生成函数自身
	的二进制代码。
static int inline mymul(int a, int b)
{
	int p;

	asm("mul %0, %1, %2"
	    :"=r"(p)			/* 一个输出;"="只写;ｒ任何一个通用寄存器 p 对应于　%0 */
	    :"r"(a), "r"(b)		/* 两个输出 */
	);

	return p;
}
